<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幻影</title>
  
  <subtitle>每一个你不满意的现在，都有一个你不努力的曾经</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://phantomabyss.github.io/"/>
  <updated>2020-06-05T08:26:26.053Z</updated>
  <id>https://phantomabyss.github.io/</id>
  
  <author>
    <name>phantom</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>属性文法和语法制导翻译</title>
    <link href="https://phantomabyss.github.io/2020/06/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/"/>
    <id>https://phantomabyss.github.io/2020/06/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91/</id>
    <published>2020-06-05T00:43:19.000Z</published>
    <updated>2020-06-05T08:26:26.053Z</updated>
    
    <content type="html"><![CDATA[<h3 id="属性文法"><a href="#属性文法" class="headerlink" title="属性文法"></a>属性文法</h3><ul><li>1、属性文法，也称属性翻译文法</li><li>2、以上下文无关文法为基础<ul><li>1、为每个文法符号(终结符或非终结符)配备若干相关的“值”(称为属性)，代表与文法符号相关相关信息，如类型、值、代码序列、符号表内容等。</li><li>2、对于文法的每个产生式都配备了一组属性的语义规则，对属性进行计算和传递。<a id="more"></a></li></ul></li><li>3、属性分为综合属性和继承属性<ul><li>1、综合属性<ul><li>1、自下而上传递信息</li><li>2、语法规则：根据右部候选式中符号的属性计算左部被定义符号的综合属性</li><li>3、语法树：根据字节点的属性和父节点自身的属性计算父节点的综合属性。</li></ul></li><li>2、继承属性<ul><li>1、自上而下传递信息</li><li>2、语法规则：根据右部候选式中的符号的属性和左部被定义符号的属性计算右部候选式中的符号的继承属性</li><li>3、语法树：根据父节点和兄弟节点的属性计算子节点的继承属性。</li></ul></li></ul></li><li>4、属性依赖<ul><li>1、对应于每个产生式$A→α$都有一套与之相关联的语义规则，每条规则的形式为(f是一个函数)：$b:=f(c_1,c_2,…,c_k)$</li><li>2、属性$b$依赖于属性$c_1,c_2,…,c_k$<ul><li>1、$b$是$A$的一个综合属性并且$c_1,c_2,…,c_k$是产生式右边文法符号的属性</li><li>2、$b$是产生右边某个文法符号的一个继承属性并且$c_1,c_2,…,c_k$是$A$或产生式右边的任何文法符号的属性</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;属性文法&quot;&gt;&lt;a href=&quot;#属性文法&quot; class=&quot;headerlink&quot; title=&quot;属性文法&quot;&gt;&lt;/a&gt;属性文法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;1、属性文法，也称属性翻译文法&lt;/li&gt;
&lt;li&gt;2、以上下文无关文法为基础&lt;ul&gt;
&lt;li&gt;1、为每个文法符号(终结符或非终结符)配备若干相关的“值”(称为属性)，代表与文法符号相关相关信息，如类型、值、代码序列、符号表内容等。&lt;/li&gt;
&lt;li&gt;2、对于文法的每个产生式都配备了一组属性的语义规则，对属性进行计算和传递。
    
    </summary>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="属性文法" scheme="https://phantomabyss.github.io/tags/%E5%B1%9E%E6%80%A7%E6%96%87%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>单调栈</title>
    <link href="https://phantomabyss.github.io/2020/05/30/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    <id>https://phantomabyss.github.io/2020/05/30/%E7%AE%97%E6%B3%95/%E5%8D%95%E8%B0%83%E6%A0%88/</id>
    <published>2020-05-30T14:05:10.000Z</published>
    <updated>2020-06-05T09:25:26.168Z</updated>
    
    <content type="html"><![CDATA[<p>首先看看单调栈的定义：</p><blockquote><ul><li>1、单调栈也是一种栈，是属于栈的应用</li><li>2、栈内元素维持单调性的应用场景<ul><li>1、单调递增(不减)栈可以找到左边第一个比当前出栈元素小(包含等于)的元素</li><li>2、单调递减(不增)栈可以找到左边第一个比当前出栈元素大(包含等于)的元素<a id="more"></a></li></ul></li></ul></blockquote><p>我们先看看一道来自Leecode的例题<br><strong><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram/" target="_blank" rel="noopener">84.柱状图中最大的矩形</a></strong></p><p>给定$n$个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。<br>求在该柱状图中，能够勾勒出来的矩形的最大面积。<br><img src="/images/算法/histogram.jpg"><br>以上是柱状图的示例，其中每个柱子的宽度为$1$，给定的高度为$[2,1,5,6,2,3]$。<br><img src="/images/算法/histogram_area.jpg"><br>图中阴影部分为所能勾勒出的最大矩形面积，其面积为$10$个单位。<br><strong>实例：</strong><br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br></pre></td></tr></table></figure></p><h4 id="方法一：暴力解法"><a href="#方法一：暴力解法" class="headerlink" title="方法一：暴力解法"></a>方法一：暴力解法</h4><p><strong>思路：</strong> 主要就是去枚举每一个的高度，看看两边可以延伸的最大宽度，对边界条件的处理比较简单。 <del>(我感觉像是没有处理一样)</del> 即初始化<code>w = 1(宽度)</code>,然后执行下面的操作：</p><ul><li>1、以当前位置向左延伸，依次累加，直到找到第一个小于当前高度的矩形的下标。</li><li>2、以当前位置向右延伸，依次累加，直到找到第一个小于当前高度的矩形的下标。</li></ul><p>因此，对于枚举的每一个高度都有一个对应的面积，每次都取最大值即可。<br>下图以第五个矩形为例：<br><img src="/images/算法/84-1.jpg" style="height:145px"><img src="/images/算法/84-2.jpg" style="height:145px"><img src="/images/算法/84-3.jpg" style="height:150px"><br>其他矩形的过程与上面所述类似<br><strong>参考代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">//枚举每个柱子的高度，然后向两边搜索可以到达的最大宽度</span></span><br><span class="line">            <span class="keyword">int</span> w = <span class="number">1</span>;  <span class="comment">//本身的宽度</span></span><br><span class="line">            <span class="comment">//向左边搜索可以到达的最大宽度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>;j &gt;= <span class="number">0</span>;j--)&#123;</span><br><span class="line">                <span class="keyword">if</span>(heights[j] &gt;= heights[i])</span><br><span class="line">                    w++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//向右边搜索可以到达的最大宽度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(heights[j] &gt;= heights[i])</span><br><span class="line">                    w++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//每次都去面积的大值</span></span><br><span class="line">            res = Math.max(res,w * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N^2)$,$N$表示数组的长度</li><li>空间复杂度：$O(1)$</li></ul><p><strong>ps</strong>: 当看到时间复杂度为$O(N^2)$,空间复杂度为$O(1)$，则应该考虑是否可以采用空间换时间的方法降低复杂度呢？(采用常见数据结构去记录一些对求解问题的信息,从而使问题可以在更短的时间内解决)，由此得到方法二采用栈记录比当前柱子高的信息便于后面更快的得到宽度。</p><h4 id="方法二：单调栈-哨兵技巧"><a href="#方法二：单调栈-哨兵技巧" class="headerlink" title="方法二：单调栈 + 哨兵技巧"></a>方法二：单调栈 + 哨兵技巧</h4><p><strong>思路：</strong> 考虑一下，当我们在遍历高度数组时，如果当前柱子的高度与前面的柱子不能构成一个递增序列，则前一个柱子的面积我们就可以确定了，因为它不能再向右边延伸了，同时由于之前的序列都是递增的，也可以起向左延伸了。此时我们可以考虑以当前柱子的高为矩形的高为标准寻找左边可以延伸的宽度，直到找到第一个比当前位置的高度低的索引，即以当前位置向前找(满足栈的定义,即先进后出),从而继续位置栈的数据是递增的，最后得出所有可能的矩形的左边界。同理，我们可以倒序遍历数组得到所有可能矩形的右边界。<br>因此我们采用栈来记录一些对我们有用的信息，并且根据前面的描述，我们可以得出栈里数据是单调递增的，即为单调栈</p><p><strong>参考代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i])</span><br><span class="line">                stack.pop();</span><br><span class="line">            left[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        stack.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i])</span><br><span class="line">                stack.pop();</span><br><span class="line">            right[i] = stack.isEmpty() ? len : stack.peek();</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            res = Math.max(res,(right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$,$N$表示数组的长度</li><li>空间复杂度：$O(1)$</li></ul><h4 id="方法三：单调栈-哨兵技巧-常数优化"><a href="#方法三：单调栈-哨兵技巧-常数优化" class="headerlink" title="方法三：单调栈 + 哨兵技巧 + 常数优化"></a>方法三：单调栈 + 哨兵技巧 + 常数优化</h4><p><strong>思路：</strong> 在方法一中，我们首先从左往右对数组进行遍历，借助单调栈求出了每根柱子的左边界，随后从右往左对数组进行遍历，借助单调栈求出了每根柱子的右边界。那么我们是否可以只遍历一次就求出答案呢？<br>答案是可以的。在方法一中，我们在对位置$i$进行入栈操作时，确定了它的左边界。从直觉上来说，与之对应的我们在对位置$i$进行出栈操作时可以确定它的右边界！仔细想一想，这确实是对的。当位置$i$被弹出栈时，说明此时遍历到的位置$i_0$的高度小于等于$height[i]$，并且在$i_0$与$i$之间没有其他高度小于等于 $height[i]$的柱子。这是因为，如果在$i$和$i_0$之间还有其它位置的高度小于等于$height[i]$的，那么在遍历到那个位置的时候，$i$应该已经被弹出栈了。所以位置$i_0$就是位置$i$的右边界。</p><p><strong>参考代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = heights.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(right, len);</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; heights[stack.peek()] &gt;= heights[i])&#123;</span><br><span class="line">                right[stack.peek()] = i;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            left[i] = stack.isEmpty() ? -<span class="number">1</span> : stack.peek();</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            res = Math.max(res,(right[i] - left[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N)$,$N$表示数组的长度</li><li>空间复杂度：$O(1)$</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先看看单调栈的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、单调栈也是一种栈，是属于栈的应用&lt;/li&gt;
&lt;li&gt;2、栈内元素维持单调性的应用场景&lt;ul&gt;
&lt;li&gt;1、单调递增(不减)栈可以找到左边第一个比当前出栈元素小(包含等于)的元素&lt;/li&gt;
&lt;li&gt;2、单调递减(不增)栈可以找到左边第一个比当前出栈元素大(包含等于)的元素
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://phantomabyss.github.io/categories/Algorithm/"/>
    
    
      <category term="单调栈" scheme="https://phantomabyss.github.io/tags/%E5%8D%95%E8%B0%83%E6%A0%88/"/>
    
      <category term="哨兵技巧" scheme="https://phantomabyss.github.io/tags/%E5%93%A8%E5%85%B5%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>LR分析法</title>
    <link href="https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LR%E5%88%86%E6%9E%90%E6%B3%95/"/>
    <id>https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LR%E5%88%86%E6%9E%90%E6%B3%95/</id>
    <published>2020-05-30T08:41:52.000Z</published>
    <updated>2020-06-05T08:46:01.368Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>规范规约：句柄作为可规约串<br>L:从左到右扫描输入串<br>R:自下而上进行规约</p></blockquote><h3 id="工作框架"><a href="#工作框架" class="headerlink" title="工作框架"></a>工作框架</h3><h4 id="产生分析表"><a href="#产生分析表" class="headerlink" title="产生分析表"></a>产生分析表</h4><p><img src="/images/编译原理/产生分析表.jpg"><a id="more"></a></p><h4 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h4><p><img src="/images/编译原理/语法分析.jpg"></p><h4 id="短语、直接短语、句柄"><a href="#短语、直接短语、句柄" class="headerlink" title="短语、直接短语、句柄"></a>短语、直接短语、句柄</h4><blockquote><ul><li>1、定义：令<code>G</code>是一个文法，<code>S</code>是文法的开始符号，假定<code>αβδ</code>是文法<code>G</code>的一个句型，如果有S $\Rightarrow$ αβδ且 A $\Rightarrow$ β，则<code>β</code>称是句型<code>αβδ</code>相对于非终结符<code>A</code>的短语</li><li>2、如果有$A \Rightarrow β$,则称<code>β</code>是句型<code>αβδ</code>相对于规则<code>A → β</code>的直接短语。</li><li>3、句柄：一个句型的最左直接短语称为该句型的句柄。</li></ul></blockquote><h5 id="识别方法"><a href="#识别方法" class="headerlink" title="识别方法"></a>识别方法</h5><ul><li>1、在一个句型对应的语法树中<ul><li>1、以某非终结符为根的两代以上的子树的所有末端节点从左到右排列就是相对于该终结符的一个短语</li><li>2、如果子树只有两代，则该短语就是直接短语</li><li>3、最左两代子树末端就是句柄</li></ul></li></ul><h4 id="规范规约-gt-语法树"><a href="#规范规约-gt-语法树" class="headerlink" title="规范规约 -&gt; 语法树"></a>规范规约 -&gt; 语法树</h4><p><img src="/images/编译原理/规范规约.jpg"></p><p><strong>ps</strong></p><ul><li>1、算法优先分析一般不等价于规范规约</li><li>2、规范规约就是最左规约</li><li>3、规范规约的逆过程就是最右推导</li><li>4、最右推导也称为规范推导</li><li>5、由规范推导退出的句型称为规范句型</li></ul><h4 id="规范规约和句柄"><a href="#规范规约和句柄" class="headerlink" title="规范规约和句柄"></a>规范规约和句柄</h4><blockquote><p>关键问题在于寻找句柄</p><ul><li>1、历史：已移入符号栈的内容</li><li>2、展望：根据产生式推测未来可能遇到的输入符号。</li></ul></blockquote><h4 id="LR分析器的结构"><a href="#LR分析器的结构" class="headerlink" title="LR分析器的结构"></a>LR分析器的结构</h4><ul><li>1、LR分析法：把“历史”和“展望”综合抽象成状态；由栈顶的状态和现行的输入符号唯一确定每一步工作。</li><li>2、<strong>LR分析器的核心：LR分析表</strong><ul><li>1、<code>ACTION[s, a]</code>: 当前状态<code>s</code>面临输入符号<code>a</code>时，应采取什么动作。</li><li>2、<code>GOTO[s, X]</code>: 状态<code>s</code>面对文法符号<code>X</code>时，下一状态是什么</li></ul></li><li><strong>3、LR分析器的性质：</strong><ul><li>1、栈内的符号串和扫描剩下的输入符号串构成了一个规范句型</li><li>2、一旦栈的内部出现了可规约串(句柄),则进行规约</li><li>3、栈内永远不会出现句柄之后的符号</li></ul></li></ul><h4 id="LR文法"><a href="#LR文法" class="headerlink" title="LR文法"></a>LR文法</h4><ul><li>1、定义：对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法称为LR文法。</li><li>2、定义：一个文法，如果能用一个每步顶多向前<code>k</code>个输入符号的LR分析器进行分析，则这个文法称为<code>LR(k)</code>文法</li><li>3、LR文法不是二义的，二义文法肯定不会是LR的。</li><li>4、LR文法是无二义文法的真子集</li></ul><h5 id="规约过程中栈内符号串"><a href="#规约过程中栈内符号串" class="headerlink" title="规约过程中栈内符号串"></a>规约过程中栈内符号串</h5><ul><li>规范规约过程中<ul><li>1、栈内的符号串和扫描剩下的输入符号串构成了一个规范句型</li><li>2、栈内如果出现了句柄，句柄一定在栈的顶部</li><li>3、栈内永远不会出现句柄之后的符号</li></ul></li></ul><h4 id="字的前缀和活前缀"><a href="#字的前缀和活前缀" class="headerlink" title="字的前缀和活前缀"></a>字的前缀和活前缀</h4><ul><li>1、字的前缀：是指字的任意首部，如字$abc$的前缀有$ε$、$a$、$ab$、$abc$</li><li>2、活前缀：是指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。即，对于规范句型<code>αβδ</code>,<code>β</code>为句柄，如果$αβ=u_1u_2…u_k$,则符号串$u_1u_2…u_r(1 &lt;= i &lt;= r)$是<code>αβδ</code>的活前缀。(<code>δ</code>必为终结符)</li><li>3、规范规约过程中，保证分析栈中总是活前缀，就说明分析采取的移进/规约动作是正确的。</li></ul><h4 id="LR-0-项目"><a href="#LR-0-项目" class="headerlink" title="LR(0)项目"></a>LR(0)项目</h4><p><img src="/images/编译原理/LR(0)项目.jpg"></p><p><strong>实例：</strong><br><img src="/images/编译原理/LR(0)项目-实例.jpg"></p><h4 id="构造识别文法所有活前缀的DFA"><a href="#构造识别文法所有活前缀的DFA" class="headerlink" title="构造识别文法所有活前缀的DFA"></a>构造识别文法所有活前缀的DFA</h4><blockquote><p><img src="/images/编译原理/识别活前缀的两种方法.jpg"></p></blockquote><ul><li>1、构造识别文法所有活前缀的NFA<br><img src="/images/编译原理/构造识别活前缀的NFA-1.jpg" style="height: 90px;"><img src="/images/编译原理/构造识别活前缀的NFA-2.jpg" style="height: 130px;"></li><li>2、把识别文法所有活前缀的NFA确定化</li></ul><p><strong>LR(0)项目集规范族</strong></p><blockquote><p>构成识别一个文法活前缀的DFA的项目集(状态)的全体称为文法的LR(0)项目集规范族。</p></blockquote><h4 id="有效项目-——-识别活前缀的另一种方法"><a href="#有效项目-——-识别活前缀的另一种方法" class="headerlink" title="有效项目  —— 识别活前缀的另一种方法"></a>有效项目  —— 识别活前缀的另一种方法</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><ul><li>1、项目$A → β_1·β_2$对活前缀$αβ_1$,其条件是存在规范推导<img src="/images/编译原理/有效项目.jpg"></li><li>2、在任何时候，分析栈中的活前缀$X_1X_2…X_m$的有效项目集正是从识别活前缀的DFA的初态出发，读出$X_1X_2…X_m$后到达的那个项目集(状态)<h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5></li></ul><p><img src="/images/编译原理/有效项目的性质-1.jpg" style="height: 70px; weight: 80px;"></p><h4 id="LR-0-项目集规范族的构造"><a href="#LR-0-项目集规范族的构造" class="headerlink" title="LR(0)项目集规范族的构造"></a>LR(0)项目集规范族的构造</h4><p><img src="/images/编译原理/LR(0)项目集规范族的构造.jpg"></p><h4 id="项目集的闭包CLOSURE"><a href="#项目集的闭包CLOSURE" class="headerlink" title="项目集的闭包CLOSURE"></a>项目集的闭包CLOSURE</h4><p><img src="/images/编译原理/项目集的闭包CLOSURE.jpg"></p><h4 id="转态转换函数"><a href="#转态转换函数" class="headerlink" title="转态转换函数"></a>转态转换函数</h4><ul><li>1、为了识别活前缀，我们定义一个状态转换函数，$GO$是一个状态转换函数，$I$是一个项目集，$X$是一个文法符号。函数值$GO(I, X)$定义为：$GO(I, X) = CLOSURE(J)$,<br>其中$J={任何形如A-&gt;aX·β的项目|A-&gt;α·Xβ属于I}$</li><li>2、直观上说，若是$I$是对某个活前缀$γ$有效的项目集，那么，$GO(I, X)$便是对$γX$有效的项目集。</li></ul><h4 id="LR-0-分析表的构成"><a href="#LR-0-分析表的构成" class="headerlink" title="LR(0)分析表的构成"></a>LR(0)分析表的构成</h4><ul><li>1、假若一个文法$G$的拓广文法$G’$的活前缀识别自动机中的每个状态(项目集)不存在下述情况：<ul><li>1、即含移进项目又含规约项目；</li><li>2、含有多个规约项目<br>那么$G$是一个$LR(0)$文法。</li></ul></li></ul><h4 id="LR-0-分析表的ACTION和GOTO子表构造"><a href="#LR-0-分析表的ACTION和GOTO子表构造" class="headerlink" title="LR(0)分析表的ACTION和GOTO子表构造"></a>LR(0)分析表的ACTION和GOTO子表构造</h4><p><img src="/images/编译原理/LR(0)分析表的ACTION和GOTO子表的构造.jpg"></p><p><strong>LR(0)分析表的构造的实例</strong><br><img src="/images/编译原理/LR(0)分析表的构造的实例.jpg"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;规范规约：句柄作为可规约串&lt;br&gt;L:从左到右扫描输入串&lt;br&gt;R:自下而上进行规约&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;工作框架&quot;&gt;&lt;a href=&quot;#工作框架&quot; class=&quot;headerlink&quot; title=&quot;工作框架&quot;&gt;&lt;/a&gt;工作框架&lt;/h3&gt;&lt;h4 id=&quot;产生分析表&quot;&gt;&lt;a href=&quot;#产生分析表&quot; class=&quot;headerlink&quot; title=&quot;产生分析表&quot;&gt;&lt;/a&gt;产生分析表&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/编译原理/产生分析表.jpg&quot;&gt;
    
    </summary>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="语法分析" scheme="https://phantomabyss.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>算符优先分析法</title>
    <link href="https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/"/>
    <id>https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/</id>
    <published>2020-05-30T08:41:43.000Z</published>
    <updated>2020-06-05T08:39:21.254Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>按照算符的优先关系和结合性质进行语法分析，适合于分析表达式</p><h4 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h4><p>优先关系是左右敏感的。<br><img src = "/images/编译原理/优先关系.jpg" style="height: 200px; width: 500px;"></p><h4 id="算符文法"><a href="#算符文法" class="headerlink" title="算符文法"></a>算符文法</h4><ul><li>1、一个文法，如果它的任一产生式的右部都不包含两个相继的(并列)的非终结符，即不包含$..QR…$形式的产生式右部，则我们称该文法为算符文法。<a id="more"></a></li><li>2、约定：<ul><li>1、<code>a, b</code>代表任一终结符</li><li>2、<code>P, Q, R</code>代表非终结符</li><li>3、<code>...</code>代表由终结符和非终结符组成的任一序列，包括空字<h4 id="算法优先文法"><a href="#算法优先文法" class="headerlink" title="算法优先文法"></a>算法优先文法</h4><img src="/images/编译原理/算符优先文法.jpg" style="height: 200px; width: 500px;"></li></ul></li><li>样例1<br><img src="/images/编译原理/算符优先文法实例.jpg" style="height: 200px; width: 500px;"></li><li>样例2<h4 id="构造优先关系表的算法"><a href="#构造优先关系表的算法" class="headerlink" title="构造优先关系表的算法"></a>构造优先关系表的算法</h4><img src="/images/编译原理/构造优先关系表的算法-1.jpg" style="height: 200px; width: 500px;"><br><img src="/images/编译原理/构造优先关系表的算法-2.jpg" style="height: 200px; width: 500px;"><h4 id="构造集合FIRSTVT-P-的算法"><a href="#构造集合FIRSTVT-P-的算法" class="headerlink" title="构造集合FIRSTVT(P)的算法"></a>构造集合FIRSTVT(P)的算法</h4>反复使用下面的两条规则构造集合<code>FIRSTVT(P)</code>集合</li><li>1、若有产生式<code>P → a...</code>或<code>P → Qa...</code>,则<code>a ∈ FIRSTVT(P)</code>.</li><li>2、若<code>a ∈ FIRSTVT(Q)</code>,且有产生式<code>P → Q...</code>,则<code>a ∈ FIRSTVT(P)</code><h5 id="算法实现方式"><a href="#算法实现方式" class="headerlink" title="算法实现方式"></a>算法实现方式</h5><ul><li>1、布尔数组<code>F[P, a]</code>,使得<code>F[P, a]</code>为真的条件是，当且仅当<code>a ∈ FIRSTVT(P)</code>.开始时，按上述规则1对每个数组元素<code>F[P, a]</code>赋初值</li><li>2、栈<code>STACK</code>把所有初值为真的数组元素<code>F[P, a]</code>的符号对<code>(P, a)</code>全都放在<code>STACK</code>之中。<br><img src="/images/编译原理/构造FIRSTVT的算法实现.jpg" style="height: 200px; width: 500px;"></li><li>3、对栈的操作：若栈<code>STACK</code>不空，就将栈顶项弹出，记此为<code>(Q, a)</code>,对于每个形成<code>P → Q..</code>的产生式，若<code>F[P, a]</code>为假则变其值为真并且将<code>(P, a)</code>推进<code>STACK</code>栈中。实现上述图片中的第2项。<h4 id="构造集合LASTVT-P-的算法"><a href="#构造集合LASTVT-P-的算法" class="headerlink" title="构造集合LASTVT(P)的算法"></a>构造集合<code>LASTVT(P)</code>的算法</h4>反复使用下面两条规则构造集合<code>LASTVT(P)</code></li><li>1、如果产生式<code>P → ...a</code>或<code>P → ...aQ</code>,则<code>a ∈ LASTVT(P)</code></li><li>2、若<code>a ∈ LASTVT(P)</code>,且有产生式<code>P → ...Q</code>,则<code>a ∈ LASTVT(P)</code></li><li>3、其他方面与上面计算<code>FIRST</code>集合的方式类似。<h4 id="构造优先关系表的算法-1"><a href="#构造优先关系表的算法-1" class="headerlink" title="构造优先关系表的算法"></a>构造优先关系表的算法</h4><img src="/images/编译原理/构造优先关系表的算法-3.jpg" style="height: 200px; width: 500px;"></li></ul></li></ul></blockquote><p>  <strong>伪代码实现</strong><br>  <img src="/images/编译原理/构造优先关系表的算法-伪代码实现.jpg" style="height: 200px; width: 500px;"></p><h4 id="算符优先文法-gt-不一定是语法树"><a href="#算符优先文法-gt-不一定是语法树" class="headerlink" title="算符优先文法 -&gt; 不一定是语法树"></a>算符优先文法 -&gt; 不一定是语法树</h4><h5 id="最左素短语"><a href="#最左素短语" class="headerlink" title="最左素短语"></a>最左素短语</h5><ul><li>1、可规约串，句型，短语</li><li>2、一个文法<code>G</code>的句型的素短语是指这样一个短语，它至少含有一个终结符，并且，除它自身之外不再包含任何更小的素短语。</li><li>3、最左素短语是指处于句型最左边的那个素短语。</li><li>4、最左素短语<br><img src="/images/编译原理/最左素短语.jpg" style="height: 200px; width: 500px;"><h5 id="算符优先程序构成"><a href="#算符优先程序构成" class="headerlink" title="算符优先程序构成"></a>算符优先程序构成</h5><ul><li>1、总控程序:根据现行栈顶符号和当前输入符号，执行动作</li><li>2、优先关系表:用于指导总控程序进行移进规约</li><li>3、分析栈<code>STACK</code>:用于存放文法符号</li><li>4、特点：</li></ul></li><li>1、优点：简单，快速</li><li>2、缺点：可能错误接受非法句子<ul><li>5、使用广泛，用于分析各类表达式。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;按照算符的优先关系和结合性质进行语法分析，适合于分析表达式&lt;/p&gt;
&lt;h4 id=&quot;优先关系&quot;&gt;&lt;a href=&quot;#优先关系&quot; class=&quot;headerlink&quot; title=&quot;优先关系&quot;&gt;&lt;/a&gt;优先关系&lt;/h4&gt;&lt;p&gt;优先关系是左右敏感的。&lt;br&gt;&lt;img src = &quot;/images/编译原理/优先关系.jpg&quot; style=&quot;height: 200px; width: 500px;&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;算符文法&quot;&gt;&lt;a href=&quot;#算符文法&quot; class=&quot;headerlink&quot; title=&quot;算符文法&quot;&gt;&lt;/a&gt;算符文法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1、一个文法，如果它的任一产生式的右部都不包含两个相继的(并列)的非终结符，即不包含$..QR…$形式的产生式右部，则我们称该文法为算符文法。
    
    </summary>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="语法分析" scheme="https://phantomabyss.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>自下而上分析</title>
    <link href="https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E6%9E%90/"/>
    <id>https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E5%88%86%E6%9E%90/</id>
    <published>2020-05-30T07:46:22.000Z</published>
    <updated>2020-06-05T08:43:10.748Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自下而上分析"><a href="#自下而上分析" class="headerlink" title="自下而上分析"></a>自下而上分析</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><ul><li>1、采用“移进-规约”思想进行自下而上的分析</li><li>2、基本思想<ul><li>1、用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(规约成)该产生式的左部符号。<a id="more"></a></li><li>2、从输入串开始，逐步规约，直到文法开始</li><li>3、规约：根据文法的产生式规则，把串中出现式的右部替换成左部符号。</li><li>4、从树叶节点开始，构造语法树</li></ul></li><li>3、自下而上的分析过程：吧边输入单词符号，边进行规约</li><li>4、核心问题：识别可规约串</li><li>5、分析树和语法树不一定完全一样。<h4 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h4><blockquote><ul><li>1、定义：令<code>G</code>是一个文法，<code>S</code>是文法的开始符号，假定<code>αβδ</code>是文法<code>G</code>的一个句型，如果有S $\Rightarrow$ αβδ且 A $\Rightarrow$ β，则<code>β</code>称是句型<code>αβδ</code>相对于非终结符<code>A</code>的短语</li><li>2、如果有A $\Rightarrow$ β,则称<code>β</code>是句型<code>αβδ</code>相对于规则<code>A → β</code>的直接短语。<h4 id="短语和直接短语"><a href="#短语和直接短语" class="headerlink" title="短语和直接短语"></a>短语和直接短语</h4></li></ul></blockquote></li><li>1、在一个句型对应的语法树中<ul><li>1、以某非终结符为根的两代以上的子树的所有末端节点从左到右排列就是相对于该终结符的一个短语</li><li>2、如果子树只有两代，则该短语就是直接短语<h4 id="自下而上分析法"><a href="#自下而上分析法" class="headerlink" title="自下而上分析法"></a>自下而上分析法</h4></li><li><a href="https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E5%88%86%E6%9E%90%E6%B3%95/#more">算符优先分析法</a></li><li><a href="https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/LR%E5%88%86%E6%9E%90%E6%B3%95/">LR分析法</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自下而上分析&quot;&gt;&lt;a href=&quot;#自下而上分析&quot; class=&quot;headerlink&quot; title=&quot;自下而上分析&quot;&gt;&lt;/a&gt;自下而上分析&lt;/h3&gt;&lt;h4 id=&quot;基本思想&quot;&gt;&lt;a href=&quot;#基本思想&quot; class=&quot;headerlink&quot; title=&quot;基本思想&quot;&gt;&lt;/a&gt;基本思想&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;1、采用“移进-规约”思想进行自下而上的分析&lt;/li&gt;
&lt;li&gt;2、基本思想&lt;ul&gt;
&lt;li&gt;1、用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(规约成)该产生式的左部符号。
    
    </summary>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="语法分析" scheme="https://phantomabyss.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>预测分析程序</title>
    <link href="https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/"/>
    <id>https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-05-30T06:30:05.000Z</published>
    <updated>2020-05-31T01:21:07.354Z</updated>
    
    <content type="html"><![CDATA[<h4 id="预测分析程序构成"><a href="#预测分析程序构成" class="headerlink" title="预测分析程序构成"></a>预测分析程序构成</h4><h5 id="总控程序"><a href="#总控程序" class="headerlink" title="总控程序"></a>总控程序</h5><blockquote><p>根据现行栈顶符号和当前输入符号，执行动作</p><h5 id="分析表M-A-a-矩阵"><a href="#分析表M-A-a-矩阵" class="headerlink" title="分析表M[A, a]矩阵"></a>分析表M[A, a]矩阵</h5><p>A∈V<sub>N</sub>,a ∈ V<sub>T</sub>是终结符或者’#’</p><h5 id="分析栈STACK"><a href="#分析栈STACK" class="headerlink" title="分析栈STACK"></a>分析栈STACK</h5><p>用于存放文法符号</p><h4 id="预测分析过程"><a href="#预测分析过程" class="headerlink" title="预测分析过程"></a>预测分析过程<a id="more"></a></h4><p>总控程序根据当前栈顶符号X和输入符号a,执行下列三个动作之一：</p><ul><li>1、若<code>X = a = ‘#’</code>，则宣布分析成功，停止分析</li><li>2、若<code>X = a ≠ &#39;#&#39;</code>,则把<code>X</code>从<code>STACK</code>栈顶逐出，让<code>a</code>指向下一个输入符号。</li><li>3、若X是一个非终结符，则查看分析表。<ul><li>1、若<code>M[X, a]</code>中存放着关于<code>X</code>的一个产生式，把<code>X</code>逐出STACK栈顶，把产生式的右部符号串按反序——推进STACK栈中(若右部符号为<code>ε</code>，则意味着不推什么东西进栈)</li><li>2、若<code>M[X, a]</code>中存放着“出错标志”，则调用出错诊察程序<code>ERROR</code><h5 id="分析表M-A-a-的构造"><a href="#分析表M-A-a-的构造" class="headerlink" title="分析表M[A, a]的构造"></a>分析表M[A, a]的构造</h5></li></ul></li><li>1、构造FIRST(α)和FOLLOW(A)</li><li>2、构造分析表M[A, a]<h5 id="分析表M-A-a-的构造算法"><a href="#分析表M-A-a-的构造算法" class="headerlink" title="分析表M[A, a]的构造算法"></a>分析表<code>M[A, a]</code>的构造算法</h5>构造G的分析表<code>M[A, a]</code>,确定每个产生式<code>A → α</code>在表中的位置</li></ul></blockquote><ul><li>1、对文法G的每个产生式<code>A → α</code>执行第2步和第3步；</li><li>2、对每个终结符<code>a ∈ FIRST(α)</code>,把<code>A → α</code>加至<code>M[A, a]</code>中</li><li>3、若<code>ε ∈ FIRST(α)</code>,则对任何<code>b ∈ FOLLOw(A)</code>把<code>A → α</code>加至<code>M[A, b]</code>中。</li><li>4、把所有无定义的<code>M[A, a]</code>标上“出错标志”。<h5 id="LL-1-文法与二义性"><a href="#LL-1-文法与二义性" class="headerlink" title="LL(1)文法与二义性"></a>LL(1)文法与二义性</h5></li><li>1、如果G是左递归或二义的，那么M至少含有一个多重定义入口，因此，消除左递归和提取左因子将有助于获得无多重定义的分析报告<code>M</code></li><li>2、一个文法<code>G</code>的预测分析表<code>M</code>不含多重定义入口，当且仅当该文法为LL(1)文法</li><li>3、LL(1)文法不是二义的。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;预测分析程序构成&quot;&gt;&lt;a href=&quot;#预测分析程序构成&quot; class=&quot;headerlink&quot; title=&quot;预测分析程序构成&quot;&gt;&lt;/a&gt;预测分析程序构成&lt;/h4&gt;&lt;h5 id=&quot;总控程序&quot;&gt;&lt;a href=&quot;#总控程序&quot; class=&quot;headerlink&quot; title=&quot;总控程序&quot;&gt;&lt;/a&gt;总控程序&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;根据现行栈顶符号和当前输入符号，执行动作&lt;/p&gt;
&lt;h5 id=&quot;分析表M-A-a-矩阵&quot;&gt;&lt;a href=&quot;#分析表M-A-a-矩阵&quot; class=&quot;headerlink&quot; title=&quot;分析表M[A, a]矩阵&quot;&gt;&lt;/a&gt;分析表M[A, a]矩阵&lt;/h5&gt;&lt;p&gt;A∈V&lt;sub&gt;N&lt;/sub&gt;,a ∈ V&lt;sub&gt;T&lt;/sub&gt;是终结符或者’#’&lt;/p&gt;
&lt;h5 id=&quot;分析栈STACK&quot;&gt;&lt;a href=&quot;#分析栈STACK&quot; class=&quot;headerlink&quot; title=&quot;分析栈STACK&quot;&gt;&lt;/a&gt;分析栈STACK&lt;/h5&gt;&lt;p&gt;用于存放文法符号&lt;/p&gt;
&lt;h4 id=&quot;预测分析过程&quot;&gt;&lt;a href=&quot;#预测分析过程&quot; class=&quot;headerlink&quot; title=&quot;预测分析过程&quot;&gt;&lt;/a&gt;预测分析过程
    
    </summary>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="语法分析" scheme="https://phantomabyss.github.io/tags/%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>递归下降分析器</title>
    <link href="https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E5%99%A8/"/>
    <id>https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E9%80%92%E5%BD%92%E4%B8%8B%E9%99%8D%E5%88%86%E6%9E%90%E5%99%A8/</id>
    <published>2020-05-30T02:18:52.000Z</published>
    <updated>2020-05-30T06:29:17.134Z</updated>
    
    <content type="html"><![CDATA[<h4 id="递归下降分析器"><a href="#递归下降分析器" class="headerlink" title="递归下降分析器"></a>递归下降分析器</h4><blockquote><ul><li>1、分析程序有一组子程序组成，对每一语法单位(非终结符)构造一个相应的子程序，识别对应的语法单位。</li><li>2、通过子程序之间的相互调用实现对输入串的识别</li><li>3、文法的定义通常是递归的，通常具有递归结构<a id="more"></a><h5 id="定义全局过程和变量"><a href="#定义全局过程和变量" class="headerlink" title="定义全局过程和变量"></a>定义全局过程和变量</h5></li><li>1、ADVANCE：把输入串指示器IP指向下一个输入符号，即读入一个单词符号</li><li>2、SYM，IP当前所指的输入符号</li><li>3、ERROR，出错处理子程序<h5 id="递归下降子程序的设计"><a href="#递归下降子程序的设计" class="headerlink" title="递归下降子程序的设计"></a>递归下降子程序的设计</h5><h5 id="扩充的巴克斯范式"><a href="#扩充的巴克斯范式" class="headerlink" title="扩充的巴克斯范式"></a>扩充的巴克斯范式</h5></li><li>1、在元符号“→”或”=”和”|”的基础上,扩充了几个元语言符号：<ul><li>1、用花括号{α}表示闭包运算α<sup>*</li><li>2、用表示{α}<sub>0</sub><sup>n</sup>可任意重复0至n次</li><li>3、用方括号[α]表示{α}<sub>0</sub><sup>1,即表示<code>α</code>的出现可有可无(α|ε)<h5 id="语法图"><a href="#语法图" class="headerlink" title="语法图"></a>语法图</h5><h5 id="JavaCC"><a href="#JavaCC" class="headerlink" title="JavaCC"></a>JavaCC</h5>可以自动产生一个自上而下的递归下降的语法分析程序(java实现)</li></ul></li></ul></blockquote><p><a href="http://javacc.java.net/" target="_blank" rel="noopener">Java Complier Complier</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;递归下降分析器&quot;&gt;&lt;a href=&quot;#递归下降分析器&quot; class=&quot;headerlink&quot; title=&quot;递归下降分析器&quot;&gt;&lt;/a&gt;递归下降分析器&lt;/h4&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、分析程序有一组子程序组成，对每一语法单位(非终结符)构造一个相应的子程序，识别对应的语法单位。&lt;/li&gt;
&lt;li&gt;2、通过子程序之间的相互调用实现对输入串的识别&lt;/li&gt;
&lt;li&gt;3、文法的定义通常是递归的，通常具有递归结构
    
    </summary>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>自上而下分析</title>
    <link href="https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90/"/>
    <id>https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%88%86%E6%9E%90/</id>
    <published>2020-05-30T01:58:01.000Z</published>
    <updated>2020-05-30T06:29:52.311Z</updated>
    
    <content type="html"><![CDATA[<h3 id="自上而下分析"><a href="#自上而下分析" class="headerlink" title="自上而下分析"></a>自上而下分析</h3><h4 id="构造不带回溯的自上而下的分析算法"><a href="#构造不带回溯的自上而下的分析算法" class="headerlink" title="构造不带回溯的自上而下的分析算法"></a>构造不带回溯的自上而下的分析算法</h4><h5 id="消除文法的左递归"><a href="#消除文法的左递归" class="headerlink" title="消除文法的左递归"></a>消除文法的左递归<a id="more"></a></h5><h5 id="提取做公共因子，克服回溯"><a href="#提取做公共因子，克服回溯" class="headerlink" title="提取做公共因子，克服回溯"></a>提取做公共因子，克服回溯</h5><h4 id="计算FIRST和FOLLOW集合"><a href="#计算FIRST和FOLLOW集合" class="headerlink" title="计算FIRST和FOLLOW集合"></a>计算FIRST和FOLLOW集合</h4><h4 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h4><h5 id="LL-1-文法的条件"><a href="#LL-1-文法的条件" class="headerlink" title="LL(1)文法的条件"></a>LL(1)文法的条件</h5><ul><li>1、文法不含左递归</li><li>2、对于文法中每一个非终结符A的各个产生式的候选首符集两两不交，如A → α<sub>1</sub> | α<sub>2</sub> | … α<sub>n</sub>,则FIRST(α<sub>i</sub>) ∩ FIRST(α<sub>i</sub>) = ∅ (i ≠ j)</li><li>3、对文法中的每个非终结符A，若它存在某个候选首符集包含<code>ε</code>，则FIRST(α<sub>i</sub>) ∩ FIRST(A) = ∅ (i ≠ j),i = 1, 2, 3…, n</li></ul><p>如果一个文法G满足以上条件，则称该文法G为LL(1)文法</p><h5 id="LL-1-分析法"><a href="#LL-1-分析法" class="headerlink" title="LL(1)分析法"></a>LL(1)分析法</h5><blockquote><p>假设要用非终结符A进行匹配，面临的输入符号为a，A的所有产生式为A → α<sub>1</sub> | α<sub>2</sub> | … α<sub>n</sub></p><ul><li>1、若a ∈ FIRST(α<sub>i</sub>),则指派α<sub>i</sub>执行分配任务；</li><li>2、若<code>a</code>不属于任何一个候选首符集，则：<ul><li>1、若<code>ε</code>属于某个FIRST(α<sub>i</sub>)且<code>a ∈ FIRST(A)</code>,则让<code>A</code>与 <code>ε</code>自动匹配。</li><li>2、否则，<code>a</code>的出现就是一种语法错误。</li></ul></li></ul></blockquote><h5 id="LL-1-文法分析方法"><a href="#LL-1-文法分析方法" class="headerlink" title="LL(1)文法分析方法"></a>LL(1)文法分析方法</h5><ul><li>1、递归下降分析器</li><li>2、预测分析程序</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;自上而下分析&quot;&gt;&lt;a href=&quot;#自上而下分析&quot; class=&quot;headerlink&quot; title=&quot;自上而下分析&quot;&gt;&lt;/a&gt;自上而下分析&lt;/h3&gt;&lt;h4 id=&quot;构造不带回溯的自上而下的分析算法&quot;&gt;&lt;a href=&quot;#构造不带回溯的自上而下的分析算法&quot; class=&quot;headerlink&quot; title=&quot;构造不带回溯的自上而下的分析算法&quot;&gt;&lt;/a&gt;构造不带回溯的自上而下的分析算法&lt;/h4&gt;&lt;h5 id=&quot;消除文法的左递归&quot;&gt;&lt;a href=&quot;#消除文法的左递归&quot; class=&quot;headerlink&quot; title=&quot;消除文法的左递归&quot;&gt;&lt;/a&gt;消除文法的左递归
    
    </summary>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>FIRST-FOLLOW集合</title>
    <link href="https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/FIRST-FOLLOW%E9%9B%86%E5%90%88/"/>
    <id>https://phantomabyss.github.io/2020/05/30/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/FIRST-FOLLOW%E9%9B%86%E5%90%88/</id>
    <published>2020-05-30T00:23:55.000Z</published>
    <updated>2020-06-05T08:52:11.221Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、构造每个文法符号的FIRST集合"><a href="#一、构造每个文法符号的FIRST集合" class="headerlink" title="一、构造每个文法符号的FIRST集合"></a>一、构造每个文法符号的FIRST集合</h3><blockquote><p>对于每个X-∈V<sub>T</sub>∪V<sub>N</sub>,连续使用下面的规则，直至每个FIRST集合不再增大为止：<br><strong>ps</strong>:$V_T$表示非终结符集合，$V_N$表示终结符集合</p><ul><li>1、若$X∈V_T$，那么<code>FIRST(X) =  {X}</code><a id="more"></a></li><li>2、若$X∈V_N$, 且有产生式$X→a…$,则把a加入到<code>FIRST(X)</code>中，若<code>X → ε</code>也是一条产生式，则把<code>ε</code>也加到<code>FIRST(X)</code>集合中</li><li>3、针对于包含多个产生式<ul><li>1、若<code>X → Y...</code>是一个产生式且Y ∈ V<sub>N</sub>,则把<code>FIRST(Y)</code>中的所有非<code>ε</code>元素都加到<code>FIRST(X)</code>集合中；</li><li>2、若$X → Y<em>1Y_2Y_3…Y</em>{i - 1}Y<em>i…Y_k$是一个产生式，$Y_1,…,Y</em>{i - 1}$都是非终结符<ul><li>1、对于任何$j$，$1 ≤ j ≤ i - 1$,$FIRST(Y<em>i)$都含有<code>ε</code>(即$Y_1…Y</em>{i - 1}) → ε$,则把FIRST(Y<sub>i</sub>)中的所有非ε元素都加到$FIRST(X)$中，</li><li>2、若所有的FIRST(Y<sub>j</sub>)均含有$ε$，$j = 1, 2, 3, … , k$,则把ε加到$FIRST(X)$中。</li></ul></li></ul></li></ul></blockquote><h3 id="二、构建每个非终结符的FOLLOW集合"><a href="#二、构建每个非终结符的FOLLOW集合" class="headerlink" title="二、构建每个非终结符的FOLLOW集合"></a>二、构建每个非终结符的FOLLOW集合</h3><blockquote><p> 对于文法<code>G</code>的每个非终结符<code>A</code>构造<code>FOLLOW(A)</code>的办法是：连续使用下面的规则，直到每个<code>FOLLOW</code>集合不再增大为止；<br><strong>ps:</strong><code>FIRST(β)\{ε}</code>表示<code>FIRST(β)</code>除去<code>ε</code>的其他元素</p><ul><li>1、对于文法的开始符号<code>S</code>,置<code>#</code>于<code>FOLLOW(S)</code>中；</li><li>2、若<code>A → αBβ</code>是一个产生式，则把<code>FIRST(β)\{ε}</code>加至<code>FOLLOW(B)</code>中；</li><li>3、若<code>A → αB</code>是一个产生式，或者<code>A → αBβ</code>是一个产生式而<code>β → ε</code>,则把<code>FOLLOW(A)</code>加到<code>FOLLOW(B)</code>中</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、构造每个文法符号的FIRST集合&quot;&gt;&lt;a href=&quot;#一、构造每个文法符号的FIRST集合&quot; class=&quot;headerlink&quot; title=&quot;一、构造每个文法符号的FIRST集合&quot;&gt;&lt;/a&gt;一、构造每个文法符号的FIRST集合&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;对于每个X-∈V&lt;sub&gt;T&lt;/sub&gt;∪V&lt;sub&gt;N&lt;/sub&gt;,连续使用下面的规则，直至每个FIRST集合不再增大为止：&lt;br&gt;&lt;strong&gt;ps&lt;/strong&gt;:$V_T$表示非终结符集合，$V_N$表示终结符集合&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、若$X∈V_T$，那么&lt;code&gt;FIRST(X) =  {X}&lt;/code&gt;
    
    </summary>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://phantomabyss.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://phantomabyss.github.io/2019/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://phantomabyss.github.io/2019/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2019-12-05T00:27:44.000Z</published>
    <updated>2020-05-29T15:37:36.199Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote><p>1、如何在连接各种计算机的传输媒体上传输数据比特流。<br>2、尽可能地屏蔽掉传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到差异，从而使数据链路层只考虑完成本层的协议和服务。<a id="more"></a></p></blockquote><h5 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h5><blockquote><p>描述为确定与传输媒体的接口有关的一些特性。</p></blockquote><ul><li>1、<strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引脚数目、和排列、固定和锁定装置等。</li><li>2、<strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压范围。</li><li>3、<strong>功能特性</strong>：指明某条线出现的某一电平的电压的意义。</li><li>4、<strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</li></ul><p><strong>ps</strong>：</p><ul><li>1、数据在计算机内部多采用并行传输的方式。</li><li>2、数据在通信线路上传输方式一般都是串行传输——逐个按照比特按照时间顺序传输</li><li>3、物理层需要完成传输方式的转换</li></ul><h3 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h3><h4 id="数据通信系统"><a href="#数据通信系统" class="headerlink" title="数据通信系统"></a>数据通信系统</h4><blockquote><p>主要由源系统(发送端，发送方)、传输系统(传输网络)和目的系统(接收端，接收方)组成</p></blockquote><p><strong>源系统</strong><br>&emsp;1、源点(源站，信源)：源点设备产生要传输的数据。<br>&emsp;2、发送器：通常源点生成的数字比特流需要通过发送器编码后才能在计算机系统中进行传输。 —— 调制器</p><p><strong>目的系统</strong><br>&emsp;1、接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信号。—— 解调器</p><h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><p>&emsp;1、模拟信号(连续信号)：代表消息的参数的取值是连续的。<br>&emsp;2、数字信号(离散信号)：代表消息的参数的取值是离散的</p><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><blockquote><p>1、用来表示向某个方向传送消息的实体。<br>2、通信电路往往包含一条发送信道和接收信道。</p></blockquote><p>根据<strong>通信双方交互的方式</strong>来看，主要分为以下三种方式：</p><ul><li>1、<strong>单向通信(单工通信)</strong>：只能有一个方向的通信而没有反方向的交互。 —— 无线电广播一类的广播。 —— 一条信道</li><li>2、<strong>双向交替通信(半双工通信)</strong>：双方都可以发送信息，但是不能同时发送消息(同理不能同时接收消息)。—— 两条信道</li><li>3、<strong>双向同时通信(全双工通信)</strong>：通信的双方可以同时发送和接收信息。—— 两条信道</li></ul><h5 id="基带信号"><a href="#基带信号" class="headerlink" title="基带信号"></a>基带信号</h5><p><strong>问题</strong>：包含较多低频成分、直流成分，但是信道不能传输低频成分以及直流成分，因此需要对其进行调制<br>主要包含以下两种调制：</p><ul><li>1、<strong>基带调制</strong>：仅仅对基带信号的波形进行变换，使其与信道特性相符。—— 编码</li><li>2、<strong>带通调制</strong>：使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，从而使其可以在模拟信道中传输。</li></ul><h5 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h5><ul><li>1、数字通信的优点：虽然信号在信道上传输会不可避免地产生失真，但在接收端只要我们可以从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就没有影响。</li></ul><p>&emsp;<strong>通信质量的影响因素</strong><br>&emsp;&emsp;1、码元传输的速率<br>&emsp;&emsp;2、信号传输的距离<br>&emsp;&emsp;3、噪声干扰<br>&emsp;&emsp;4、传输媒体的质量<br>&emsp;<strong>ps</strong>：在任何信道中，码元传输的速率都是由上限的，传输速率超过此上限，就会出现严重的码间干扰的问题，使接收端对码元的判决称为不可能。<br>&emsp;<strong>信噪比</strong></p><blockquote><p>信号的平均功率和噪声的平均功率之比，记为S/N.</p></blockquote><p><strong>信噪比(dB) = $10*log_{10}(S/N)$</strong><br>&emsp;<strong>香农公式</strong><br><strong>极限信息传输速率C是：$C = W * log_2(1 + S/N)(bit/s)$</strong></p><ul><li>1、W为信道的带宽(Hz)</li><li>2、S为信道内所传信号的平均功率；</li><li>3、N为信道内部的高斯噪声功率。</li></ul><p>&emsp;香农公式表明了信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。<br>&emsp;香农公式的意义是只要信息传输速率低于信道的极限信息传输效率，就一定存在某种办法来实现无差错的传输。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1、如何在连接各种计算机的传输媒体上传输数据比特流。&lt;br&gt;2、尽可能地屏蔽掉传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到差异，从而使数据链路层只考虑完成本层的协议和服务。
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://phantomabyss.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://phantomabyss.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SecureCRT连接Linux时拒绝访问</title>
    <link href="https://phantomabyss.github.io/2019/12/01/secureCRT/SecureCRT%E8%BF%9E%E6%8E%A5Linux%E6%97%B6%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/"/>
    <id>https://phantomabyss.github.io/2019/12/01/secureCRT/SecureCRT%E8%BF%9E%E6%8E%A5Linux%E6%97%B6%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/</id>
    <published>2019-12-01T03:39:09.000Z</published>
    <updated>2020-06-05T08:58:20.380Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：SecureCRT连接虚拟机出现远程主机拒绝访问(<del>忘记截图了呀。。。</del>)</strong><br>我遇到的问题是主机和Linux可以相互ping通的情况下，使用SecureCRT连接Linux时拒绝访问主机，<br>如果您本机和Linuxping不通的话，可以先看看其他博客关于网络方面的配置。<a id="more"></a></p><ul><li>1、首先检查是否因为防火墙是否是否已经关闭<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> ufw status <span class="comment">#查看防火墙的状态</span></span><br></pre></td></tr></table></figure>ps:如果ufw命令使用不了，可以使用以下命令进行安装：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install ufw</span><br><span class="line"><span class="comment"># 顺便说说防火墙开启的命令吧</span></span><br><span class="line">sudo ufw enable</span><br><span class="line">sudo ufw<span class="built_in"> default </span>deny # 开启了防火墙并随系统启动同时关闭所有外部对本机的访问（本机访问外部正常）</span><br></pre></td></tr></table></figure></li><li>2、如果没有关闭，Linux(Ubuntu)下关闭防火墙的命令为<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">disable</span> <span class="comment">#关闭防火墙</span></span><br></pre></td></tr></table></figure>2、Ubuntu没有安装SSH2的服务，可以在终端中使用apt命令安装：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install openssh-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>又是一个坑呀！！！！<br>本文参考<a href="https://blog.csdn.net/weixin_36989023/article/details/67061937" target="_blank" rel="noopener">windows下使用SecureCRT远程linux虚拟机出现主机拒绝访问的问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问题描述：SecureCRT连接虚拟机出现远程主机拒绝访问(&lt;del&gt;忘记截图了呀。。。&lt;/del&gt;)&lt;/strong&gt;&lt;br&gt;我遇到的问题是主机和Linux可以相互ping通的情况下，使用SecureCRT连接Linux时拒绝访问主机，&lt;br&gt;如果您本机和Linuxping不通的话，可以先看看其他博客关于网络方面的配置。
    
    </summary>
    
    
    
      <category term="SecureCRT" scheme="https://phantomabyss.github.io/tags/SecureCRT/"/>
    
      <category term="问题" scheme="https://phantomabyss.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>故障管理工具</title>
    <link href="https://phantomabyss.github.io/2019/12/01/jvm/%E6%95%85%E9%9A%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://phantomabyss.github.io/2019/12/01/jvm/%E6%95%85%E9%9A%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2019-12-01T00:39:35.000Z</published>
    <updated>2020-05-29T15:38:33.430Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h4><blockquote><p>主要有两个可视化工具：JConsole   VisualVM</p></blockquote><h5 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h5><blockquote><p>1、基于JMX的可视化监视、管理工具<br>  2、功能：针对JMX MBean进行管理。<br>    &emsp;MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问。<a id="more"></a></p></blockquote><ul><li>1、使用jconsole.exe启动JConsole后，将自动搜索出本机运行的所有虚拟机的进程。</li><li>2、</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JDK的可视化工具&quot;&gt;&lt;a href=&quot;#JDK的可视化工具&quot; class=&quot;headerlink&quot; title=&quot;JDK的可视化工具&quot;&gt;&lt;/a&gt;JDK的可视化工具&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;主要有两个可视化工具：JConsole   VisualVM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;JConsole：Java监视与管理控制台&quot;&gt;&lt;a href=&quot;#JConsole：Java监视与管理控制台&quot; class=&quot;headerlink&quot; title=&quot;JConsole：Java监视与管理控制台&quot;&gt;&lt;/a&gt;JConsole：Java监视与管理控制台&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;1、基于JMX的可视化监视、管理工具&lt;br&gt;  2、功能：针对JMX MBean进行管理。&lt;br&gt;    &amp;emsp;MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问。
    
    </summary>
    
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机性能监控</title>
    <link href="https://phantomabyss.github.io/2019/11/28/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <id>https://phantomabyss.github.io/2019/11/28/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</id>
    <published>2019-11-28T12:01:08.000Z</published>
    <updated>2020-06-05T09:03:08.146Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h4><blockquote><p>1、JDK的bin目录下其他命令行程序(exe文件)主要用于监视虚拟机和故障处理的工作。<br> 2、如果需要监控运行于JDK1.5的虚拟机之上的程序，在程序启动的时候需要添加参数“-Dcom.sun.management.jmxremote”开启JMX管理功能，否则部分基于JMX的工具无法使用。<br> 3、如果被监控程序运行于JDK1.6之上的虚拟机的JMX管理默认是开启的，虚拟机启动时不需要添加任何参数。<a id="more"></a></p></blockquote><ul><li>主要有以下工具：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">主要作用</th></tr></thead><tbody><tr><td style="text-align:center">jps</td><td style="text-align:center">JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td style="text-align:center">jstat</td><td style="text-align:center">JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据</td></tr><tr><td style="text-align:center">jinfo</td><td style="text-align:center">Configuration Info for Java,显示虚拟机配置信息</td></tr><tr><td style="text-align:center">jmap</td><td style="text-align:center">Memory Map for Java,生成虚拟机的内存转储快照(heapdump文件)</td></tr><tr><td style="text-align:center">jhat</td><td style="text-align:center">JVM Heap Dump Brower,用于分析heapdump文件</td></tr><tr><td style="text-align:center">jstack</td><td style="text-align:center">Stack Trace for Java,显示虚拟机的线程快照</td></tr></tbody></table></div><h5 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps:虚拟机进程状况工具"></a>jps:虚拟机进程状况工具</h5><blockquote><p>功能：列出正在运行的虚拟机进程，并显示虚拟机执行主类(main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID(LVMID)。<br>  命令格式：jps [ options ] [ hostid ]</p></blockquote><ul><li>1、jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。</li><li>2、jps工具主要选项见下表：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-q</td><td style="text-align:center">只输出LVMID，省略主类的名称</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:center">输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:center">输出主类的全名，如果进程执行的是jar包，输出Jar路径</td></tr><tr><td style="text-align:center">-v</td><td style="text-align:center">输出虚拟机进程启动时JVM参数</td></tr></tbody></table></div><h5 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="headerlink" title="jstat:虚拟机统计信息监视工具"></a>jstat:虚拟机统计信息监视工具</h5><blockquote><p>功能：<br>&emsp;1、用于监视虚拟机各种运行状态信息的命令行工作。<br>&emsp;2、可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p></blockquote><ul><li>1、命令格式：jstat [ option  vmid  [interval[s|ms]]  [count] ]<ul><li>1、如果是本地虚拟机进程，VMID与LVMID一致，如果是远程虚拟机进程，VMID的格式为：[protocol:][//]lvmid[@hostname[:port]/servername]</li><li>2、参数interval和count表示查询间隔与次数，如果省略表示值查询一次。<br>  如：jstat -gc 2764  250   20表示每250毫秒查询一次进程2764收集状况，一共查询20次。</li><li>3、option表示用户希望查询的虚拟机信息，主要包含三类(类装载、垃圾收集运行期编译状况)</li></ul></li><li>2、jstat工具主要选项见下表：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-class</td><td style="text-align:center">监视类装载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td style="text-align:center">-gc</td><td style="text-align:center">监视Java堆状况，包括Eden区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td></tr><tr><td style="text-align:center">-gccapacity</td><td style="text-align:center">监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td style="text-align:center">-gcutil</td><td style="text-align:center">监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td style="text-align:center">-gccause</td><td style="text-align:center">与-gcutil功能一样，但是额外输出导致上一次GC产生的原因</td></tr><tr><td style="text-align:center">-gcnew</td><td style="text-align:center">监视新生代GC状况</td></tr><tr><td style="text-align:center">-gcnewcapacity</td><td style="text-align:center">监视内容与-gcnew基本相同，输出主要关注使用的最大、最小空间</td></tr><tr><td style="text-align:center">-gccold</td><td style="text-align:center">监视老年代GC状况</td></tr><tr><td style="text-align:center">-gccoldcapacity</td><td style="text-align:center">监视内容基本-gccold基本相同，输出关注使用到的最大、最小空间</td></tr><tr><td style="text-align:center">-gcpermcapacity</td><td style="text-align:center">输出永久代使用到的最大、最小空间</td></tr><tr><td style="text-align:center">-complier</td><td style="text-align:center">输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td style="text-align:center">-printcompilation</td><td style="text-align:center">输出已经被JIT编译的方法</td></tr></tbody></table></div><h5 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo:Java配置信息工具"></a>jinfo:Java配置信息工具</h5><blockquote><p>功能：实时查看和调整虚拟机各项参数。<br>命令格式：jinfo [  option  ] pid</p></blockquote><ul><li>1、jinfo -flag pid:查询未被显示指定的参数的系统默认值。</li><li>2、jinfo -sysprops pid:把虚拟机的System.getProperties()的内容打印出来。</li></ul><h6 id="jmap-Java内存映像工具"><a href="#jmap-Java内存映像工具" class="headerlink" title="jmap:Java内存映像工具"></a>jmap:Java内存映像工具</h6><blockquote><p>功能：<br>&emsp;1、用于存储堆转储快照。<br>&emsp;2、可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。<br>命令格式：jmap [ option  ] vmid</p></blockquote><ul><li>option的合法值以及具体含义如下表：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-dump</td><td style="text-align:center">生成Java堆转储快照，格式为；-dump:[live, ]format=b, file=<filename>,其中live子参数说明是否只dump储存活的对象</td></tr><tr><td style="text-align:center">-finalizerinfo</td><td style="text-align:center">显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效</td></tr><tr><td style="text-align:center">-heap</td><td style="text-align:center">显示Java对详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效</td></tr><tr><td style="text-align:center">-histo</td><td style="text-align:center">显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td style="text-align:center">-permstat</td><td style="text-align:center">以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td></tr><tr><td style="text-align:center">-F</td><td style="text-align:center">当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td></tr></tbody></table></div><h5 id="jhat-虚拟机堆转储快照分析工具"><a href="#jhat-虚拟机堆转储快照分析工具" class="headerlink" title="jhat:虚拟机堆转储快照分析工具"></a>jhat:虚拟机堆转储快照分析工具</h5><blockquote><p>与jmap命令搭配只用，来分析jmap生成的堆存储快照。分析结果可以再浏览器中查看。</p></blockquote><p>一般都不会使用该命令，比较消耗硬件资源，而且比较耗时。</p><h5 id="jstack-Java堆栈跟踪工具"><a href="#jstack-Java堆栈跟踪工具" class="headerlink" title="jstack:Java堆栈跟踪工具"></a>jstack:Java堆栈跟踪工具</h5><blockquote><p>用于生成虚拟机当前时刻的线程快照。<br>线程快照表示当前虚拟机内每一条线程正在执行的方法堆栈的集合。<br>命令格式：jstack  [  option  ] vmid</p></blockquote><ul><li>options选项的合法值以及具体含义如下表所示：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">选项</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">-F</td><td style="text-align:center">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td style="text-align:center">-l</td><td style="text-align:center">除堆栈外，显示关于锁的附加信息</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:center">如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table></div><p><strong>生成线程快照的目的：</strong><br>&emsp;&emsp;定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待。</p><h5 id="HDIS：JIT生成代码反汇编"><a href="#HDIS：JIT生成代码反汇编" class="headerlink" title="HDIS：JIT生成代码反汇编"></a>HDIS：JIT生成代码反汇编</h5><blockquote><p>功能：让Hotspot的-XX:+PrintAssembly指令调用它来把动态生成的本地代码还原为汇编代码输出，同时还生成了大量非常有价值的注释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Bar().sum(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JDK命令行工具&quot;&gt;&lt;a href=&quot;#JDK命令行工具&quot; class=&quot;headerlink&quot; title=&quot;JDK命令行工具&quot;&gt;&lt;/a&gt;JDK命令行工具&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1、JDK的bin目录下其他命令行程序(exe文件)主要用于监视虚拟机和故障处理的工作。&lt;br&gt; 2、如果需要监控运行于JDK1.5的虚拟机之上的程序，在程序启动的时候需要添加参数“-Dcom.sun.management.jmxremote”开启JMX管理功能，否则部分基于JMX的工具无法使用。&lt;br&gt; 3、如果被监控程序运行于JDK1.6之上的虚拟机的JMX管理默认是开启的，虚拟机启动时不需要添加任何参数。
    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GitBash中文乱码</title>
    <link href="https://phantomabyss.github.io/2019/11/26/git/GitBash%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>https://phantomabyss.github.io/2019/11/26/git/GitBash%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2019-11-26T12:24:46.000Z</published>
    <updated>2020-05-15T10:23:07.375Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1、在终端的空白界面，点击鼠标右键，弹出的菜单选择【options】，弹出如下的菜单界面，然后选择【Text】-&gt;【Local】，然后在下拉菜单中选择zh_CN,在【Character set】下拉菜单中选择【utf-8】,最后点击apply，保存即可。<a id="more"></a></li><li>2、执行命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br><span class="line">git status #显示执行结果</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;1、在终端的空白界面，点击鼠标右键，弹出的菜单选择【options】，弹出如下的菜单界面，然后选择【Text】-&amp;gt;【Local】，然后在下拉菜单中选择zh_CN,在【Character set】下拉菜单中选择【utf-8】,最后点击apply，保存即可。
    
    </summary>
    
    
      <category term="git" scheme="https://phantomabyss.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://phantomabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GitBash中文乱码</title>
    <link href="https://phantomabyss.github.io/2019/11/26/hexo/GitBash%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>https://phantomabyss.github.io/2019/11/26/hexo/GitBash%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2019-11-26T12:24:46.000Z</published>
    <updated>2020-05-15T10:23:50.693Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1、在终端的空白界面，点击鼠标右键，弹出的菜单选择【options】，弹出如下的菜单界面，然后选择【Text】-&gt;【Local】，然后在下拉菜单中选择zh_CN,在【Character set】下拉菜单中选择【utf-8】,最后点击apply，保存即可。<a id="more"></a></li><li>2、执行命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br><span class="line">git status #显示执行结果</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;1、在终端的空白界面，点击鼠标右键，弹出的菜单选择【options】，弹出如下的菜单界面，然后选择【Text】-&amp;gt;【Local】，然后在下拉菜单中选择zh_CN,在【Character set】下拉菜单中选择【utf-8】,最后点击apply，保存即可。
    
    </summary>
    
    
      <category term="git" scheme="https://phantomabyss.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://phantomabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>内存分配与回收</title>
    <link href="https://phantomabyss.github.io/2019/11/26/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/"/>
    <id>https://phantomabyss.github.io/2019/11/26/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/</id>
    <published>2019-11-26T11:03:05.000Z</published>
    <updated>2020-06-05T09:04:47.132Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><blockquote><p>内存分配主要是在堆上(也有可能经过JIT编译器拆散为标量类型间接地在栈上分配)，对象主要分配在新生代的Eden上，如果启动了本地线程分配缓冲，则按线程优先在TLAB上分配。当时少数情况也可以直接分配在老年代中。<a id="more"></a></p></blockquote><h5 id="对象优先在Eden上分配"><a href="#对象优先在Eden上分配" class="headerlink" title="对象优先在Eden上分配"></a>对象优先在Eden上分配</h5><ul><li>1、多数情况下，对象在新生代Eden中分配</li><li>2、Eden中内存不够时虚拟机就会发起一次Minor GC</li><li>3、虚拟机提供-XX:+PrintGCDdtails告诉虚拟机在发生垃圾收集行为时，打印内存回收日志以及进程退出时内存各区域的分配情况。</li><li>4、大对象直接进入老年代：大对象即大量连续内存空间的Java对象。如果经常出现大对象就需要内存还有没有使用的空间的时候就提前触发垃圾收集以获取足够的连续空间来安置。</li><li>5、虚拟机提供了-XX:PretenureSizeThreshold参数(只对Serial和ParNew两款收集器有效)使大于设置值的对象直接在老年代分配，避免在Eden区以及两个Survivor区之间发生大量的内存复制。 —— 新生代采用复制算法收集。</li><li>6、长期存活的对象将进入老年代：虚拟机给每个对象都定义了一个对象年龄计数器，如果对象在Eden出生后并经过一次Minor后仍然存活，并且能被Survivor容纳的话将被移到Survivor空间中，并且把计数器的值设为1，此后没熬过一岁，它的年龄就增加1，当增加到了一定的程度就会被晋升到老年代中，参数-XX:MaxTenuringThreshold可以设置晋升到老年代的阈值。</li><li>7、动态对象年龄判定：如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。</li><li>8、空间分配担保：进行Minor之前，需要检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则此次的Minor是安全的，如果不成立，虚拟机就会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，接着就会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，就会”冒险”进行一次Minor GC，如果小于，就不允许冒险，进行一次Full GC.</li></ul><h5 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h5><ul><li>1、Minor GC:新生代GC，指发生在新生代的垃圾收集动作，大多数的Java对象都是朝生夕灭，因此Monitor GC非常频繁，一般回收速度也比较快。</li><li>2、Full GC(Major GC):老年代GC，指发生在老年代的GC，出现了Full GC,经常会伴随至少一次Minor GC,Major GC的速度一般会比Minor GC慢1倍以上。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;内存分配&quot;&gt;&lt;a href=&quot;#内存分配&quot; class=&quot;headerlink&quot; title=&quot;内存分配&quot;&gt;&lt;/a&gt;内存分配&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;内存分配主要是在堆上(也有可能经过JIT编译器拆散为标量类型间接地在栈上分配)，对象主要分配在新生代的Eden上，如果启动了本地线程分配缓冲，则按线程优先在TLAB上分配。当时少数情况也可以直接分配在老年代中。
    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器</title>
    <link href="https://phantomabyss.github.io/2019/11/26/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://phantomabyss.github.io/2019/11/26/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2019-11-26T06:25:19.000Z</published>
    <updated>2020-06-05T09:06:04.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><blockquote><p>是一种以获取最短回收停顿时间为目标的收集器。</p></blockquote><ul><li>1、CMS收集器是基于标记-清楚算法实现的。</li><li>2、运作过程：<ul><li>1、初始标记：标记GC roots能直接关联的对象，速度快。</li><li>2、并发标记：进行GCTracing的过程<a id="more"></a></li><li>3、重新标记：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，停顿时间较初始标记稍长，较并发标记时间短。</li><li>4、并发清除</li></ul></li><li>3、并发标记和并发清除（耗时最长）过程都可以与用户线程一起并发执行。—— CMS收集器的内存回收过程是与用户线程一起并发执行的。</li><li>4、CMS收集器的缺点：<ul><li>1、CMS收集器对CPU资源非常敏感。(默认启动的回收线程数是(CPU数量 + 3)/4).解决办法：虚拟机提供了一种“增量式并发收集器”的CMS收集器变种(效果不明显，不值得提倡)。</li><li>2、CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败(CMS运行期间预留的内存无法满足用户程序的需要)而导致另一次Full GC的产生。<br>浮动垃圾：在标记过程之后产生的垃圾，只能等待下一次GC的时候再次回收这些垃圾。</li><li>3、手机结束后会有大量的碎片产生，无法找到足够大的连续空间给大对象分配内存，就需要提前触发一次Full GC。CMS收集器提供了<ul><li>-XX:+UserCMSCompactAtFullCollection参数解决该问题，用于在内存空间不够的时候需要进行Full GC的时候开启内存碎片的合并整理过程(无法并发)。</li><li>-XX:CMSFullGCsBeforeCompatction用于设置执行多少次不压缩的Full GC后，然后接着来一次压缩的。</li></ul></li></ul></li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><blockquote><p>是以一款面向服务端应用的垃圾收集器。</p></blockquote><h5 id="G1收集器的特点"><a href="#G1收集器的特点" class="headerlink" title="G1收集器的特点"></a>G1收集器的特点</h5><ul><li>1、并行并发：利用多核CPU的硬件优势缩短停顿时间，原来执行GC动作需要停顿的java程序，G1可以并发让java程序继续执行。</li><li>2、分代收集：采用不同的方式去处理新创建的对象以及已经存活了一段时间、熬过多次GC的旧对象。</li><li>3、空间整合：G1整体是基于标记-整理算法实现的，局部是基于复制算法实现的，这就意味着G1在运行的时候不会产生大量的空间碎片，导致分配大对象时无法找到足够的内部直接开启下一次GC。</li><li>4、可预测的停顿：通过建立可预测的停顿时间模型(避免在Java堆中进行全区域的垃圾收集)，能让使用者明确指定在一个长度为M毫秒的之间判断内，消耗在垃圾收集的时间不得超过N毫秒。</li></ul><h5 id="G1收集器在内存区域的分布"><a href="#G1收集器在内存区域的分布" class="headerlink" title="G1收集器在内存区域的分布"></a>G1收集器在内存区域的分布</h5><ul><li>1、G1之前的收集器都将收集的范围分为整个新生代或者老年代。</li><li>2、G1将Java堆的内存分为多个大小相等的独立区域，虽然还是保留到了新生代和老年代，但是它们之间不是隔离的了，而是一部分Region(不需要连续)的集合。</li><li>3、G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，然后在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值更大的Region。</li><li>4、G1中的Region之间的对象引用以及其他收集器之间老年代与新生代之间的对象引用都是通过Remembered Set来避免全堆扫描的。<h5 id="G1收集器的运作过程"><a href="#G1收集器的运作过程" class="headerlink" title="G1收集器的运作过程"></a>G1收集器的运作过程</h5></li><li>1、初始标记:标记一下GC roots能直接关联的对象，并且修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region对象中创建新对象，此时需要停顿线程(时间很短)。</li><li>2、并发标记：从GC roots中开始对Java堆中进行可达性分析，找出存活的对象，此时耗时较长(但是可以和用户程序并发执行)。</li><li>3、最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的标记记录，虚拟机将这段变化的内容记录在线程Remembered Set logs中，最后将其合并到Remembered Set中，该阶段需要停顿线程，但是可以并行执行。</li><li>4、筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间制定回收计划。<h5 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h5></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;收集器&quot;&gt;&lt;a href=&quot;#收集器&quot; class=&quot;headerlink&quot; title=&quot;收集器&quot;&gt;&lt;/a&gt;收集器&lt;/h3&gt;&lt;h4 id=&quot;CMS收集器&quot;&gt;&lt;a href=&quot;#CMS收集器&quot; class=&quot;headerlink&quot; title=&quot;CMS收集器&quot;&gt;&lt;/a&gt;CMS收集器&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;是一种以获取最短回收停顿时间为目标的收集器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、CMS收集器是基于标记-清楚算法实现的。&lt;/li&gt;
&lt;li&gt;2、运作过程：&lt;ul&gt;
&lt;li&gt;1、初始标记：标记GC roots能直接关联的对象，速度快。&lt;/li&gt;
&lt;li&gt;2、并发标记：进行GCTracing的过程
    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>自动内存管理机制</title>
    <link href="https://phantomabyss.github.io/2019/11/21/jvm/%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/"/>
    <id>https://phantomabyss.github.io/2019/11/21/jvm/%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/</id>
    <published>2019-11-21T14:57:32.000Z</published>
    <updated>2020-05-29T15:40:14.760Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><ul><li>1、定义：给对象添加一个引用计数器，每当一个地方引用的时候，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的。<a id="more"></a></li><li>2、引用计数存在的问题(见以下的样例)：<br>  但是主流的Java虚拟机里面没有使用引用计数算法来管理内存，主要原因是因为引用计数算法很难解决对象之间相互循环引用的问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoryManage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个成员属性的作用的占点内存，以便在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line"></span><br><span class="line">objA = <span class="keyword">null</span>;</span><br><span class="line">objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GC</span></span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ReferenceCountingGC.testGC();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5></li><li><p>1、定义：通过可达性分析来判断对象是否存活的。（Java、C#、Lisp）</p></li><li><p>2、算法思路：通过一系列称为“GC roots”的对象作为起始点，并以此节点向下搜索，搜索走过的路径为引用链，当一个对象到GC roots没有任何引用链时，则说明此对象是不可用的。</p></li><li><p>3、Java中可以作为GC roots的对象有：</p><ul><li>a、虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>b、方法区中类静态属性引用的对象。</li><li>c、方法区中常量引用的对象。</li><li>d、本地方法栈中JNI（Native方法）引用的对象。</li></ul></li></ul><h5 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h5><p>&emsp;<strong>强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</strong></p><ul><li>1、强引用：如“Object obj = new Object();”;只用强引用存在，垃圾收集器就不会回收被引用的对象。</li><li>2、软引用：描述一些还有用但并非必需的对象，在内存将要发生内存溢出之前，垃圾收集器会对这些对象进行二次回收（第一次回收已死的对象），如果这次回收内存还是不够，就会跑出内存溢出异常。(SoftReference类实现弱引用)</li><li>3、弱引用：描述一些非必需的对象，被弱引用关联的对象只能生存到下一次垃圾回收之前，无论内存是否足够使用，弱引用关联的对象都会被回收。(WeakReference类来实现弱引用)</li><li>4、虚引用：也称为幽灵引用或者幻影引用，虚引用不会对对象的生存时间造成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的目的是能在这个对象被垃圾收集器回收时收到一个系统通知。(PhantomReference类实现虚引用)</li></ul><h5 id="一个对象的死亡至少要经历两次标记过程"><a href="#一个对象的死亡至少要经历两次标记过程" class="headerlink" title="一个对象的死亡至少要经历两次标记过程:"></a>一个对象的死亡至少要经历两次标记过程:</h5><ul><li><p>1、如果对象在执行可达性分析后没有与GCroots相连的引用链，就会被打上第一次标记并且进行一次筛选，</p><pre><code>  筛选条件是：此对象是否有必要执行finalize()方法。(当对象没有覆盖finalize()方法或者虚拟机之前已经调用过该方法了，虚拟机将这两种情况都当做“没有必要执行”)</code></pre></li><li><p>2、如果对象的finalize()方法有必要执行，则将其放入一个名为F-Queue的队列中，稍后由一个Finalizer线程(虚拟机自动建立、低优先级)去执行它——既虚拟机会触发这个方法执行，但是不会等待它执行结束(防止finalize()方法执行缓慢或者陷入死循环)</p></li><li><p>3、如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关系，那么在第二次标记的时候就被移出即将回收的集合。否则就被垃圾收集器回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoryManage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下代码的作用：</span></span><br><span class="line"><span class="comment"> * 1、对象可以再被GC时自我拯救</span></span><br><span class="line"><span class="comment"> * 2、但是只可以自救一次，因为一个对象的finalize()方法只会被虚拟机调用一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"yes,I am still alive;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.finalize();</span><br><span class="line">System.out.println(<span class="string">"finalize method executed"</span>);</span><br><span class="line">FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象第一次拯救自己</span></span><br><span class="line">SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">//finalize方法的优先级较低，暂停0.5秒以等待它</span></span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"no,I am dead;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面的代码与上面是一致的，但是这次自救会失败</span></span><br><span class="line"><span class="comment"> * 因为任何一个对象的finalize方法只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> * 如果该对象下次再次被回收时，finalize方法就不会再次执行了，自救也就失败了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">//finalize方法的优先级比较低，暂停0.5秒等地</span></span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"no,I am dead"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="回收方法区：回收的效率很低，主要回收废弃常量和无用的类。"><a href="#回收方法区：回收的效率很低，主要回收废弃常量和无用的类。" class="headerlink" title="回收方法区：回收的效率很低，主要回收废弃常量和无用的类。"></a>回收方法区：回收的效率很低，主要回收废弃常量和无用的类。</h5><h6 id="无用的类需要满足的条件："><a href="#无用的类需要满足的条件：" class="headerlink" title="无用的类需要满足的条件："></a>无用的类需要满足的条件：</h6><ul><li>1、该类所有的实例都已经被回收，java堆中不存在该类的任何实例。</li><li>2、加载该类的ClassLoader已经被回收</li><li>3、该类对象的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;自动内存管理机制&quot;&gt;&lt;a href=&quot;#自动内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;自动内存管理机制&quot;&gt;&lt;/a&gt;自动内存管理机制&lt;/h4&gt;&lt;h5 id=&quot;引用计数算法&quot;&gt;&lt;a href=&quot;#引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;引用计数算法&quot;&gt;&lt;/a&gt;引用计数算法&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;1、定义：给对象添加一个引用计数器，每当一个地方引用的时候，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的。
    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="https://phantomabyss.github.io/2019/11/16/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>https://phantomabyss.github.io/2019/11/16/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2019-11-16T14:29:23.000Z</published>
    <updated>2020-05-29T15:40:59.739Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java虚拟机内存的各个区域"><a href="#Java虚拟机内存的各个区域" class="headerlink" title="Java虚拟机内存的各个区域"></a>Java虚拟机内存的各个区域</h4><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong><em>程序计数器</em></strong></h5><blockquote><p>当前线程的所执行的字节码的行号指示器——线程私有的内存<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>、Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的。——每个线程都有一个独立的程序计数器，线程之间互不影响。</span><br><span class="line">* <span class="number">2</span>、线程执行Java方法时：程序计数器记录正在执行的虚拟机字节码指令的地址。</span><br><span class="line">* <span class="number">3</span>、线程执行Native方法时：计数器的值为空（Undefined）。</span><br></pre></td></tr></table></figure><br><a id="more"></a></p><h5 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a><strong><em>Java虚拟机栈</em></strong></h5><p>描述的是Java方法执行的内存模型——线程私有的内存。<br>生命周期与线程相同<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>、每个方法在执行的同时都会创建一个栈帧用于存储局部变量表(栈内存)、操作数栈、动态链接、方法出口等信息。</span><br><span class="line">* <span class="number">2</span>、局部变量表存储八种基本数据类型(*<span class="built_in">bool</span>ean,byte,char,short,<span class="built_in">int</span>,<span class="built_in">float</span>,<span class="built_in">double</span>,long*)、对象引用类型(*<span class="built_in">ref</span>erence*类型)、*returnAddress*类型。</span><br><span class="line">   * <span class="built_in">ref</span>erence类型：可能是一个指向对象起始地址的引用指针，也可能是一个指向一个代表对象的句柄或其他与此对象相关的位置。</span><br><span class="line">* <span class="number">3</span>、$调用\stackrel&#123;方法&#125;&#123;\longrightarrow&#125;完成\stackrel&#123;等价于&#125;&#123;\Longrightarrow&#125;入栈\stackrel&#123;栈帧&#125;&#123;\longrightarrow&#125;出栈(虚拟机栈)$</span><br><span class="line">* <span class="number">4</span>、局部变量表所需的内存空间在编译期间完成分配，运行期间不会改变。</span><br><span class="line">* <span class="number">5</span>、Java虚拟机对该区域定义的两种异常规范：</span><br><span class="line">  * <span class="number">1</span>、线程请求的栈深度大于虚拟机所允许的深度。——*StackOverflowError*</span><br><span class="line">  * <span class="number">2</span>、若虚拟机支持扩展后任然无法申请到足够的内存。——*OutofMemeoryError*</span><br></pre></td></tr></table></figure></p><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong><em>本地方法栈</em></strong></h5><p>为虚拟机使用的Native方法服务，具体的虚拟机可以对其自由实现。<br><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>、HotSpot将本地方法栈与虚拟机栈合二为一了。</span><br><span class="line">* <span class="number">2</span>、本地方法栈的两种异常规范与虚拟机栈相同。</span><br></pre></td></tr></table></figure></p><h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong><em>Java堆</em></strong></h5><p>是被所有线程共享的一块内存区域，在虚拟机启动时创建，存放对象实例，分配内存<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 1、所有的对象实例以及数组都要在堆上分配内存。</span><br><span class="line">* 2、随着JIT编译器和逃逸分析技术的发展：<span class="formula">$$ <span class="tag">\<span class="name">left</span></span><span class="tag">\<span class="name">&#123;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula">栈上分配 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">标量替换优先技术</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">right</span></span>.</span></span><br><span class="line"><span class="formula">$$</span>会发生一些变化。</span><br><span class="line">* 3、是垃圾收集器管理的主要区域——都采用分代收集算法(新生代，老年代)。</span><br></pre></td></tr></table></figure></p><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong><em>方法区</em></strong></h5><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译、编译后的代码等数据。是各个线程共享的区域。——永久代</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>、不需要选择一块连续的内存或可以选择固定大小或可扩展。</span><br><span class="line">* <span class="number">2.</span>还可以选择不实现垃圾收集</span><br><span class="line">* <span class="number">3</span>、该区域的内存回收主要是针对常量池的回收和对类型的卸载。</span><br></pre></td></tr></table></figure><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong><em>运行时常量池</em></strong></h5><blockquote><p>Class文件中的一项信息时常量池，用于存放编译期生成的各种字面量和符号引用，这些内容在类加载中</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Java虚拟机内存的各个区域&quot;&gt;&lt;a href=&quot;#Java虚拟机内存的各个区域&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机内存的各个区域&quot;&gt;&lt;/a&gt;Java虚拟机内存的各个区域&lt;/h4&gt;&lt;h5 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;程序计数器&lt;/em&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;当前线程的所执行的字节码的行号指示器——线程私有的内存&lt;br&gt;&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的。——每个线程都有一个独立的程序计数器，线程之间互不影响。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、线程执行Java方法时：程序计数器记录正在执行的虚拟机字节码指令的地址。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;、线程执行Native方法时：计数器的值为空（Undefined）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>解决每次部署到GitHub时都需要输入用户名和密码的问题</title>
    <link href="https://phantomabyss.github.io/2019/09/27/hexo/%E8%A7%A3%E5%86%B3%E9%83%A8%E7%BD%B2%E6%97%B6%E6%AF%8F%E6%AC%A1%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://phantomabyss.github.io/2019/09/27/hexo/%E8%A7%A3%E5%86%B3%E9%83%A8%E7%BD%B2%E6%97%B6%E6%AF%8F%E6%AC%A1%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2019-09-27T15:17:37.000Z</published>
    <updated>2020-05-15T09:59:33.799Z</updated>
    
    <content type="html"><![CDATA[<p>对于每次使用git bash部署博客到GitHub都需要输入用户名和密码，总觉得很烦，经过在网上查找的一些资料和自己一些理解记录一哈过程，便于以后查询。<br><a id="more"></a><br><strong>前提：<br>    &emsp;使用ssh连接的方式可以避免每次部署项目的时候需要输入用户名和密码的过程，同时也比较安全。</strong></p><ul><li><strong>1、配置ssh密钥</strong><br><del>如果已经在GitHub配置ssh密钥，可以跳过</del><ul><li>1.1、生成ssh密钥对<ul><li>1.1.1、查看自己是否已经生成了ssh密钥对,如果没有，文件夹为空。<br><img src="/images/hexo/ssh.jpg"></li><li>1.1.2、在git bash命令行执行以下命令,建议在生成密钥的过程中不要输入用户名和密码，否则后面就需要其他的配置，一路回车就行了，执行完成后就会生成对应的密钥文件。<br><img src="/images/hexo/getssh.jpg"><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C 你的GitHub对应的邮箱</span><br></pre></td></tr></table></figure><img src="/images/hexo/isapub.jpg"><br>.pub后缀的文件就是你的公钥</li></ul></li><li>1.2、在GitHub上添加公钥<br>  将上面.pub文件的内容复制到github的ssh keys(头像处的settings-&gt;SSH and GPG keys-&gt;New SSH key)处，title可以随便取。<br>  <img src="/images/hexo/sshkeys.jpg"></li></ul></li><li><strong>2、修改站点目录配置文件</strong><ul><li>2.1、修改_config.yml文件，将部署方式从https方式修改为ssh，直接打开_config.yml搜索deployment即可<br><img src="/images/hexo/deployment.jpg"></li><li>2.2、接下来直接在hexo的根目录下打开git bash命令行执行以下两条命令即可<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"username"</span>    <span class="comment"># GitHub的用户名</span></span><br><span class="line">$ git config --global user.email <span class="string">"yourEmail"</span>  <span class="comment"># GitHub注册时你输入的邮箱</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>3、重新部署hexo到GitHub</strong><br>  重新打开git bash命令行再次部署到GitHub即可</li></ul><p>到这里我的就行了，建议你们可以去试试。如果问题还没有解决，可以参考原博文的方法。</p><p>以上内容参考于：<br>    <a href="https://zhidao.baidu.com/question/2121621163479338627.html" target="_blank" rel="noopener">为什么hexo用git部署到github上每次都要输入用户名和密码</a><br>    <a href="https://www.cnblogs.com/yaoel/p/5381826.html" target="_blank" rel="noopener">使用Github SSH Key来避免Hexo部署时输入账户密码</a><br>    <a href="https://blog.csdn.net/jinmie0193/article/details/81589661" target="_blank" rel="noopener">github设置SSH登陆</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于每次使用git bash部署博客到GitHub都需要输入用户名和密码，总觉得很烦，经过在网上查找的一些资料和自己一些理解记录一哈过程，便于以后查询。&lt;br&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://phantomabyss.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://phantomabyss.github.io/tags/hexo/"/>
    
      <category term="GitHub" scheme="https://phantomabyss.github.io/tags/GitHub/"/>
    
  </entry>
  
</feed>
