<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>幻影</title>
  
  <subtitle>每一个你不满意的现在，都有一个你不努力的曾经</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://phantomabyss.github.io/"/>
  <updated>2019-12-05T02:04:30.861Z</updated>
  <id>https://phantomabyss.github.io/</id>
  
  <author>
    <name>phantom</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>物理层</title>
    <link href="https://phantomabyss.github.io/2019/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://phantomabyss.github.io/2019/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%89%A9%E7%90%86%E5%B1%82/</id>
    <published>2019-12-05T00:27:44.000Z</published>
    <updated>2019-12-05T02:04:30.861Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><blockquote><p>1、如何在连接各种计算机的传输媒体上传输数据比特流。<br>2、尽可能地屏蔽掉传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到差异，从而使数据链路层只考虑完成本层的协议和服务。</p></blockquote><h5 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h5><blockquote><p>描述为确定与传输媒体的接口有关的一些特性。</p></blockquote><ul><li>1、<strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引脚数目、和排列、固定和锁定装置等。</li><li>2、<strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压范围。</li><li>3、<strong>功能特性</strong>：指明某条线出现的某一电平的电压的意义。</li><li>4、<strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</li></ul><p><strong>ps</strong>：</p><ul><li>1、数据在计算机内部多采用并行传输的方式。</li><li>2、数据在通信线路上传输方式一般都是串行传输——逐个按照比特按照时间顺序传输</li><li>3、物理层需要完成传输方式的转换</li></ul><h3 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h3><h4 id="数据通信系统"><a href="#数据通信系统" class="headerlink" title="数据通信系统"></a>数据通信系统</h4><blockquote><p>主要由源系统(发送端，发送方)、传输系统(传输网络)和目的系统(接收端，接收方)组成</p></blockquote><p><strong>源系统</strong><br>&emsp;1、源点(源站，信源)：源点设备产生要传输的数据。<br>&emsp;2、发送器：通常源点生成的数字比特流需要通过发送器编码后才能在计算机系统中进行传输。 —— 调制器</p><p><strong>目的系统</strong><br>&emsp;1、接收器：接收传输系统传送过来的信号，并把它转换为能够被目的设备处理的信号。—— 解调器</p><h5 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h5><p>&emsp;1、模拟信号(连续信号)：代表消息的参数的取值是连续的。<br>&emsp;2、数字信号(离散信号)：代表消息的参数的取值是离散的</p><h4 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h4><blockquote><p>1、用来表示向某个方向传送消息的实体。<br>2、通信电路往往包含一条发送信道和接收信道。</p></blockquote><p>根据<strong>通信双方交互的方式</strong>来看，主要分为以下三种方式：</p><ul><li>1、<strong>单向通信(单工通信)</strong>：只能有一个方向的通信而没有反方向的交互。 —— 无线电广播一类的广播。 —— 一条信道</li><li>2、<strong>双向交替通信(半双工通信)</strong>：双方都可以发送信息，但是不能同时发送消息(同理不能同时接收消息)。—— 两条信道</li><li>3、<strong>双向同时通信(全双工通信)</strong>：通信的双方可以同时发送和接收信息。—— 两条信道</li></ul><h5 id="基带信号"><a href="#基带信号" class="headerlink" title="基带信号"></a>基带信号</h5><p><strong>问题</strong>：包含较多低频成分、直流成分，但是信道不能传输低频成分以及直流成分，因此需要对其进行调制<br>主要包含以下两种调制：</p><ul><li>1、<strong>基带调制</strong>：仅仅对基带信号的波形进行变换，使其与信道特性相符。—— 编码</li><li>2、<strong>带通调制</strong>：使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，从而使其可以在模拟信道中传输。</li></ul><h5 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h5><ul><li>1、数字通信的优点：虽然信号在信道上传输会不可避免地产生失真，但在接收端只要我们可以从失真的波形中能够识别出原来的信号，那么这种失真对通信质量就没有影响。</li></ul><p>&emsp;<strong>通信质量的影响因素</strong><br>&emsp;&emsp;1、码元传输的速率<br>&emsp;&emsp;2、信号传输的距离<br>&emsp;&emsp;3、噪声干扰<br>&emsp;&emsp;4、传输媒体的质量<br>&emsp;<strong>ps</strong>：在任何信道中，码元传输的速率都是由上限的，传输速率超过此上限，就会出现严重的码间干扰的问题，使接收端对码元的判决称为不可能。<br>&emsp;<strong>信噪比</strong></p><blockquote><p>信号的平均功率和噪声的平均功率之比，记为S/N.</p></blockquote><p><strong>信噪比(dB) = $10*log_{10}(S/N)$</strong><br>&emsp;<strong>香农公式</strong><br><strong>极限信息传输速率C是：$C = W * log_2(1 + S/N)(bit/s)$</strong></p><ul><li>1、W为信道的带宽(Hz)</li><li>2、S为信道内所传信号的平均功率；</li><li>3、N为信道内部的高斯噪声功率。</li></ul><p>&emsp;香农公式表明了信道的带宽或信道中的信噪比越大，信息的极限传输速率就越高。<br>&emsp;香农公式的意义是只要信息传输速率低于信道的极限信息传输效率，就一定存在某种办法来实现无差错的传输。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1、如何在连接各种计算机的传输媒体上传输数据比特流。&lt;br&gt;2、尽可能地屏蔽掉传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到差异，从而使数据链路层只考虑完成本层的协议和服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;主要任务&quot;&gt;&lt;a href=&quot;#主要任务&quot; class=&quot;headerlink&quot; title=&quot;主要任务&quot;&gt;&lt;/a&gt;主要任务&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;描述为确定与传输媒体的接口有关的一些特性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、&lt;strong&gt;机械特性&lt;/strong&gt;：指明接口所用接线器的形状和尺寸、引脚数目、和排列、固定和锁定装置等。&lt;/li&gt;
&lt;li&gt;2、&lt;strong&gt;电气特性&lt;/strong&gt;：指明在接口电缆的各条线上出现的电压范围。&lt;/li&gt;
&lt;li&gt;3、&lt;strong&gt;功能特性&lt;/strong&gt;：指明某条线出现的某一电平的电压的意义。&lt;/li&gt;
&lt;li&gt;4、&lt;strong&gt;过程特性&lt;/strong&gt;：指明对于不同功能的各种可能事件的出现顺序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;ps&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、数据在计算机内部多采用并行传输的方式。&lt;/li&gt;
&lt;li&gt;2、数据在通信线路上传输方式一般都是串行传输——逐个按照比特按照时间顺序传输&lt;/li&gt;
&lt;li&gt;3、物理层需要完成传输方式的转换&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;数据通信&quot;&gt;&lt;a href=&quot;#数据通信&quot; class=&quot;headerlink&quot; title=&quot;数据通信&quot;&gt;&lt;/a&gt;数据通信&lt;/h3&gt;&lt;h4 id=&quot;数据通信系统&quot;&gt;&lt;a href=&quot;#数据通信系统&quot; class=&quot;headerlink&quot; title=&quot;数据通信系统&quot;&gt;&lt;/a&gt;数据通信系统&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;主要由源系统(发送端，发送方)、传输系统(传输网络)和目的系统(接收端，接收方)组成&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="https://phantomabyss.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://phantomabyss.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SecureCRT连接Linux时拒绝访问</title>
    <link href="https://phantomabyss.github.io/2019/12/01/secureCRT/SecureCRT%E8%BF%9E%E6%8E%A5Linux%E6%97%B6%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/"/>
    <id>https://phantomabyss.github.io/2019/12/01/secureCRT/SecureCRT%E8%BF%9E%E6%8E%A5Linux%E6%97%B6%E6%8B%92%E7%BB%9D%E8%AE%BF%E9%97%AE/</id>
    <published>2019-12-01T03:39:09.000Z</published>
    <updated>2019-12-01T03:46:27.233Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：SecureCRT连接虚拟机出现远程主机拒绝访问(忘记截图了呀。。。)</strong><br>我遇到的问题是主机和Linux可以相互ping通的情况下，使用SecureCRT连接Linux时拒绝访问主机，<br>如果您本机和Linuxping不通的话，可以先看看其他博客关于网络方面的配置。</p><ul><li>1、首先检查是否因为防火墙是否是否已经关闭<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> ufw status <span class="comment">#查看防火墙的状态</span></span><br></pre></td></tr></table></figure>ps:如果ufw命令使用不了，可以使用以下命令进行安装：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install ufw</span><br><span class="line"><span class="comment"># 顺便说说防火墙开启的命令吧</span></span><br><span class="line">sudo ufw enable</span><br><span class="line">sudo ufw<span class="built_in"> default </span>deny # 开启了防火墙并随系统启动同时关闭所有外部对本机的访问（本机访问外部正常）</span><br></pre></td></tr></table></figure></li><li>2、如果没有关闭，Linux(Ubuntu)下关闭防火墙的命令为<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw <span class="built_in">disable</span> <span class="comment">#关闭防火墙</span></span><br></pre></td></tr></table></figure>2、Ubuntu没有安装SSH2的服务，可以在终端中使用apt命令安装：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install openssh-<span class="keyword">server</span></span><br></pre></td></tr></table></figure>又是一个坑呀！！！！<br>本文参考<a href="https://blog.csdn.net/weixin_36989023/article/details/67061937" target="_blank" rel="noopener">windows下使用SecureCRT远程linux虚拟机出现主机拒绝访问的问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问题描述：SecureCRT连接虚拟机出现远程主机拒绝访问(忘记截图了呀。。。)&lt;/strong&gt;&lt;br&gt;我遇到的问题是主机和Linux可以相互ping通的情况下，使用SecureCRT连接Linux时拒绝访问主机，&lt;br&gt;如果您本机和Linuxping不通的话，可以先看看其他博客关于网络方面的配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、首先检查是否因为防火墙是否是否已经关闭&lt;figure class=&quot;highlight nginx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;sudo&lt;/span&gt; ufw status &lt;span class=&quot;comment&quot;&gt;#查看防火墙的状态&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
ps:如果ufw命令使用不了，可以使用以下命令进行安装：&lt;figure class=&quot;highlight routeros&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;builtin-name&quot;&gt;get&lt;/span&gt; install ufw&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 顺便说说防火墙开启的命令吧&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo ufw enable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo ufw&lt;span class=&quot;built_in&quot;&gt; default &lt;/span&gt;deny # 开启了防火墙并随系统启动同时关闭所有外部对本机的访问（本机访问外部正常）&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;2、如果没有关闭，Linux(Ubuntu)下关闭防火墙的命令为&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo ufw &lt;span class=&quot;built_in&quot;&gt;disable&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;#关闭防火墙&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
2、Ubuntu没有安装SSH2的服务，可以在终端中使用apt命令安装：&lt;figure class=&quot;highlight pgsql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt-&lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; install openssh-&lt;span class=&quot;keyword&quot;&gt;server&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
又是一个坑呀！！！！&lt;br&gt;本文参考&lt;a href=&quot;https://blog.csdn.net/weixin_36989023/article/details/67061937&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;windows下使用SecureCRT远程linux虚拟机出现主机拒绝访问的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

    
    </summary>
    
    
    
      <category term="SecureCRT" scheme="https://phantomabyss.github.io/tags/SecureCRT/"/>
    
      <category term="问题" scheme="https://phantomabyss.github.io/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>故障管理工具</title>
    <link href="https://phantomabyss.github.io/2019/12/01/jvm/%E6%95%85%E9%9A%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <id>https://phantomabyss.github.io/2019/12/01/jvm/%E6%95%85%E9%9A%9C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</id>
    <published>2019-12-01T00:39:35.000Z</published>
    <updated>2019-12-01T07:04:59.501Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h4><blockquote><p>主要有两个可视化工具：JConsole   VisualVM</p></blockquote><h5 id="JConsole：Java监视与管理控制台"><a href="#JConsole：Java监视与管理控制台" class="headerlink" title="JConsole：Java监视与管理控制台"></a>JConsole：Java监视与管理控制台</h5><blockquote><p>1、基于JMX的可视化监视、管理工具<br>  2、功能：针对JMX MBean进行管理。<br>    &emsp;MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问。</p></blockquote><ul><li>1、使用jconsole.exe启动JConsole后，将自动搜索出本机运行的所有虚拟机的进程。</li><li>2、</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JDK的可视化工具&quot;&gt;&lt;a href=&quot;#JDK的可视化工具&quot; class=&quot;headerlink&quot; title=&quot;JDK的可视化工具&quot;&gt;&lt;/a&gt;JDK的可视化工具&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;主要有两个可视化工具：JConsole   VisualVM&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;JConsole：Java监视与管理控制台&quot;&gt;&lt;a href=&quot;#JConsole：Java监视与管理控制台&quot; class=&quot;headerlink&quot; title=&quot;JConsole：Java监视与管理控制台&quot;&gt;&lt;/a&gt;JConsole：Java监视与管理控制台&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;1、基于JMX的可视化监视、管理工具&lt;br&gt;  2、功能：针对JMX MBean进行管理。&lt;br&gt;    &amp;emsp;MBean可以使用代码、中间件服务器的管理控制台或者所有符合JMX规范的软件进行访问。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、使用jconsole.exe启动JConsole后，将自动搜索出本机运行的所有虚拟机的进程。&lt;/li&gt;
&lt;li&gt;2、&lt;/li&gt;
&lt;/ul&gt;

    
    </summary>
    
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机性能监控</title>
    <link href="https://phantomabyss.github.io/2019/11/28/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/"/>
    <id>https://phantomabyss.github.io/2019/11/28/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7/</id>
    <published>2019-11-28T12:01:08.000Z</published>
    <updated>2019-11-28T14:49:46.393Z</updated>
    
    <content type="html"><![CDATA[<h4 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h4><blockquote><p>1、JDK的bin目录下其他命令行程序(exe文件)主要用于监视虚拟机和故障处理的工作。<br> 2、如果需要监控运行于JDK1.5的虚拟机之上的程序，在程序启动的时候需要添加参数“-Dcom.sun.management.jmxremote”开启JMX管理功能，否则部分基于JMX的工具无法使用。<br> 3、如果被监控程序运行于JDK1.6之上的虚拟机的JMX管理默认是开启的，虚拟机启动时不需要添加任何参数。</p></blockquote><ul><li>主要有以下工具：<table><thead><tr><th align="center">选项</th><th align="center">主要作用</th></tr></thead><tbody><tr><td align="center">jps</td><td align="center">JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程</td></tr><tr><td align="center">jstat</td><td align="center">JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据</td></tr><tr><td align="center">jinfo</td><td align="center">Configuration Info for Java,显示虚拟机配置信息</td></tr><tr><td align="center">jmap</td><td align="center">Memory Map for Java,生成虚拟机的内存转储快照(heapdump文件)</td></tr><tr><td align="center">jhat</td><td align="center">JVM Heap Dump Brower,用于分析heapdump文件</td></tr><tr><td align="center">jstack</td><td align="center">Stack Trace for Java,显示虚拟机的线程快照</td></tr></tbody></table></li></ul><h5 id="jps-虚拟机进程状况工具"><a href="#jps-虚拟机进程状况工具" class="headerlink" title="jps:虚拟机进程状况工具"></a>jps:虚拟机进程状况工具</h5><blockquote><p>功能：列出正在运行的虚拟机进程，并显示虚拟机执行主类(main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID(LVMID)。<br>  命令格式：jps [ options ] [ hostid ]</p></blockquote><ul><li>1、jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。</li><li>2、jps工具主要选项见下表：<table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-q</td><td align="center">只输出LVMID，省略主类的名称</td></tr><tr><td align="center">-m</td><td align="center">输出虚拟机进程启动时传递给主类main()函数的参数</td></tr><tr><td align="center">-l</td><td align="center">输出主类的全名，如果进程执行的是jar包，输出Jar路径</td></tr><tr><td align="center">-v</td><td align="center">输出虚拟机进程启动时JVM参数</td></tr></tbody></table></li></ul><h5 id="jstat-虚拟机统计信息监视工具"><a href="#jstat-虚拟机统计信息监视工具" class="headerlink" title="jstat:虚拟机统计信息监视工具"></a>jstat:虚拟机统计信息监视工具</h5><blockquote><p>功能：<br>&emsp;1、用于监视虚拟机各种运行状态信息的命令行工作。<br>&emsp;2、可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。</p></blockquote><ul><li>1、命令格式：jstat [ option  vmid  [interval[s|ms]]  [count] ]<ul><li>1、如果是本地虚拟机进程，VMID与LVMID一致，如果是远程虚拟机进程，VMID的格式为：[protocol:][//]lvmid[@hostname[:port]/servername]</li><li>2、参数interval和count表示查询间隔与次数，如果省略表示值查询一次。<br>  如：jstat -gc 2764  250   20表示每250毫秒查询一次进程2764收集状况，一共查询20次。</li><li>3、option表示用户希望查询的虚拟机信息，主要包含三类(类装载、垃圾收集运行期编译状况)</li></ul></li><li>2、jstat工具主要选项见下表：<table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-class</td><td align="center">监视类装载、卸载数量、总空间以及类装载所耗费的时间</td></tr><tr><td align="center">-gc</td><td align="center">监视Java堆状况，包括Eden区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td></tr><tr><td align="center">-gccapacity</td><td align="center">监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td></tr><tr><td align="center">-gcutil</td><td align="center">监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td></tr><tr><td align="center">-gccause</td><td align="center">与-gcutil功能一样，但是额外输出导致上一次GC产生的原因</td></tr><tr><td align="center">-gcnew</td><td align="center">监视新生代GC状况</td></tr><tr><td align="center">-gcnewcapacity</td><td align="center">监视内容与-gcnew基本相同，输出主要关注使用的最大、最小空间</td></tr><tr><td align="center">-gccold</td><td align="center">监视老年代GC状况</td></tr><tr><td align="center">-gccoldcapacity</td><td align="center">监视内容基本-gccold基本相同，输出关注使用到的最大、最小空间</td></tr><tr><td align="center">-gcpermcapacity</td><td align="center">输出永久代使用到的最大、最小空间</td></tr><tr><td align="center">-complier</td><td align="center">输出JIT编译器编译过的方法、耗时等信息</td></tr><tr><td align="center">-printcompilation</td><td align="center">输出已经被JIT编译的方法</td></tr></tbody></table></li></ul><h5 id="jinfo-Java配置信息工具"><a href="#jinfo-Java配置信息工具" class="headerlink" title="jinfo:Java配置信息工具"></a>jinfo:Java配置信息工具</h5><blockquote><p>功能：实时查看和调整虚拟机各项参数。<br>命令格式：jinfo [  option  ] pid</p></blockquote><ul><li>1、jinfo -flag pid:查询未被显示指定的参数的系统默认值。</li><li>2、jinfo -sysprops pid:把虚拟机的System.getProperties()的内容打印出来。</li></ul><h6 id="jmap-Java内存映像工具"><a href="#jmap-Java内存映像工具" class="headerlink" title="jmap:Java内存映像工具"></a>jmap:Java内存映像工具</h6><blockquote><p>功能：<br>&emsp;1、用于存储堆转储快照。<br>&emsp;2、可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等。<br>命令格式：jmap [ option  ] vmid</p></blockquote><ul><li>option的合法值以及具体含义如下表：<table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-dump</td><td align="center">生成Java堆转储快照，格式为；-dump:[live, ]format=b, file=<filename>,其中live子参数说明是否只dump储存活的对象</td></tr><tr><td align="center">-finalizerinfo</td><td align="center">显示在F-Queue中等待Finalizer线程执行finalize方法的对象。只在Linux/Solaris平台下有效</td></tr><tr><td align="center">-heap</td><td align="center">显示Java对详细信息，如使用哪种回收器、参数配置、分代状况等。只在Linux/Solaris平台下有效</td></tr><tr><td align="center">-histo</td><td align="center">显示堆中对象统计信息，包括类、实例数量、合计容量</td></tr><tr><td align="center">-permstat</td><td align="center">以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td></tr><tr><td align="center">-F</td><td align="center">当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td></tr></tbody></table></li></ul><h5 id="jhat-虚拟机堆转储快照分析工具"><a href="#jhat-虚拟机堆转储快照分析工具" class="headerlink" title="jhat:虚拟机堆转储快照分析工具"></a>jhat:虚拟机堆转储快照分析工具</h5><blockquote><p>与jmap命令搭配只用，来分析jmap生成的堆存储快照。分析结果可以再浏览器中查看。</p></blockquote><p>一般都不会使用该命令，比较消耗硬件资源，而且比较耗时。</p><h5 id="jstack-Java堆栈跟踪工具"><a href="#jstack-Java堆栈跟踪工具" class="headerlink" title="jstack:Java堆栈跟踪工具"></a>jstack:Java堆栈跟踪工具</h5><blockquote><p>用于生成虚拟机当前时刻的线程快照。<br>线程快照表示当前虚拟机内每一条线程正在执行的方法堆栈的集合。<br>命令格式：jstack  [  option  ] vmid</p></blockquote><ul><li>options选项的合法值以及具体含义如下表所示：<table><thead><tr><th align="center">选项</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-F</td><td align="center">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td align="center">-l</td><td align="center">除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="center">-m</td><td align="center">如果调用到本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table></li></ul><p><strong>生成线程快照的目的：</strong><br>&emsp;&emsp;定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待。</p><h5 id="HDIS：JIT生成代码反汇编"><a href="#HDIS：JIT生成代码反汇编" class="headerlink" title="HDIS：JIT生成代码反汇编"></a>HDIS：JIT生成代码反汇编</h5><blockquote><p>功能：让Hotspot的-XX:+PrintAssembly指令调用它来把动态生成的本地代码还原为汇编代码输出，同时还生成了大量非常有价值的注释。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Bar().sum(<span class="number">3</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;JDK命令行工具&quot;&gt;&lt;a href=&quot;#JDK命令行工具&quot; class=&quot;headerlink&quot; title=&quot;JDK命令行工具&quot;&gt;&lt;/a&gt;JDK命令行工具&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;1、JDK的bin目录下其他命令行程序(exe文件)主要用于监视虚拟机和故障处理的工作。&lt;br&gt; 2、如果需要监控运行于JDK1.5的虚拟机之上的程序，在程序启动的时候需要添加参数“-Dcom.sun.management.jmxremote”开启JMX管理功能，否则部分基于JMX的工具无法使用。&lt;br&gt; 3、如果被监控程序运行于JDK1.6之上的虚拟机的JMX管理默认是开启的，虚拟机启动时不需要添加任何参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;主要有以下工具：&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;选项&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;主要作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jps&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jstat&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;JVM Statistics Monitoring Tool,用于收集HotSpot虚拟机各方面的运行数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jinfo&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Configuration Info for Java,显示虚拟机配置信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jmap&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Memory Map for Java,生成虚拟机的内存转储快照(heapdump文件)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jhat&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;JVM Heap Dump Brower,用于分析heapdump文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;jstack&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;Stack Trace for Java,显示虚拟机的线程快照&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;jps-虚拟机进程状况工具&quot;&gt;&lt;a href=&quot;#jps-虚拟机进程状况工具&quot; class=&quot;headerlink&quot; title=&quot;jps:虚拟机进程状况工具&quot;&gt;&lt;/a&gt;jps:虚拟机进程状况工具&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;功能：列出正在运行的虚拟机进程，并显示虚拟机执行主类(main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID(LVMID)。&lt;br&gt;  命令格式：jps [ options ] [ hostid ]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、jps可以通过RMI协议查询开启了RMI服务的远程虚拟机进程状态，hostid为RMI注册表中注册的主机名。&lt;/li&gt;
&lt;li&gt;2、jps工具主要选项见下表：&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;选项&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-q&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;只输出LVMID，省略主类的名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-m&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;输出虚拟机进程启动时传递给主类main()函数的参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-l&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;输出主类的全名，如果进程执行的是jar包，输出Jar路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-v&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;输出虚拟机进程启动时JVM参数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;jstat-虚拟机统计信息监视工具&quot;&gt;&lt;a href=&quot;#jstat-虚拟机统计信息监视工具&quot; class=&quot;headerlink&quot; title=&quot;jstat:虚拟机统计信息监视工具&quot;&gt;&lt;/a&gt;jstat:虚拟机统计信息监视工具&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;功能：&lt;br&gt;&amp;emsp;1、用于监视虚拟机各种运行状态信息的命令行工作。&lt;br&gt;&amp;emsp;2、可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、命令格式：jstat [ option  vmid  [interval[s|ms]]  [count] ]&lt;ul&gt;
&lt;li&gt;1、如果是本地虚拟机进程，VMID与LVMID一致，如果是远程虚拟机进程，VMID的格式为：[protocol:][//]lvmid[@hostname[:port]/servername]&lt;/li&gt;
&lt;li&gt;2、参数interval和count表示查询间隔与次数，如果省略表示值查询一次。&lt;br&gt;  如：jstat -gc 2764  250   20表示每250毫秒查询一次进程2764收集状况，一共查询20次。&lt;/li&gt;
&lt;li&gt;3、option表示用户希望查询的虚拟机信息，主要包含三类(类装载、垃圾收集运行期编译状况)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2、jstat工具主要选项见下表：&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;center&quot;&gt;选项&lt;/th&gt;
&lt;th align=&quot;center&quot;&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-class&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;监视类装载、卸载数量、总空间以及类装载所耗费的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-gc&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;监视Java堆状况，包括Eden区、老年代、永久代等的容量、已用空间、GC时间合计等信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-gccapacity&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-gcutil&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-gccause&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;与-gcutil功能一样，但是额外输出导致上一次GC产生的原因&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-gcnew&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;监视新生代GC状况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-gcnewcapacity&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;监视内容与-gcnew基本相同，输出主要关注使用的最大、最小空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-gccold&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;监视老年代GC状况&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-gccoldcapacity&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;监视内容基本-gccold基本相同，输出关注使用到的最大、最小空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-gcpermcapacity&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;输出永久代使用到的最大、最小空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-complier&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;输出JIT编译器编译过的方法、耗时等信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;center&quot;&gt;-printcompilation&lt;/td&gt;
&lt;td align=&quot;center&quot;&gt;输出已经被JIT编译的方法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;jinfo-Java配置信息工具&quot;&gt;&lt;a href=&quot;#jinfo-Java配置信息工具&quot; class=&quot;headerlink&quot; title=&quot;jinfo:Java配置信息工具&quot;&gt;&lt;/a&gt;jinfo:Java配置信息工具&lt;/h5&gt;
    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GitBash中文乱码</title>
    <link href="https://phantomabyss.github.io/2019/11/26/git/GitBash%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>https://phantomabyss.github.io/2019/11/26/git/GitBash%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2019-11-26T12:24:46.000Z</published>
    <updated>2020-05-15T10:23:07.375Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1、在终端的空白界面，点击鼠标右键，弹出的菜单选择【options】，弹出如下的菜单界面，然后选择【Text】-&gt;【Local】，然后在下拉菜单中选择zh_CN,在【Character set】下拉菜单中选择【utf-8】,最后点击apply，保存即可。<a id="more"></a></li><li>2、执行命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br><span class="line">git status #显示执行结果</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;1、在终端的空白界面，点击鼠标右键，弹出的菜单选择【options】，弹出如下的菜单界面，然后选择【Text】-&amp;gt;【Local】，然后在下拉菜单中选择zh_CN,在【Character set】下拉菜单中选择【utf-8】,最后点击apply，保存即可。
    
    </summary>
    
    
      <category term="git" scheme="https://phantomabyss.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://phantomabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>GitBash中文乱码</title>
    <link href="https://phantomabyss.github.io/2019/11/26/hexo/GitBash%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/"/>
    <id>https://phantomabyss.github.io/2019/11/26/hexo/GitBash%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81/</id>
    <published>2019-11-26T12:24:46.000Z</published>
    <updated>2020-05-15T10:23:50.693Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1、在终端的空白界面，点击鼠标右键，弹出的菜单选择【options】，弹出如下的菜单界面，然后选择【Text】-&gt;【Local】，然后在下拉菜单中选择zh_CN,在【Character set】下拉菜单中选择【utf-8】,最后点击apply，保存即可。<a id="more"></a></li><li>2、执行命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath false</span><br><span class="line">git status #显示执行结果</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;1、在终端的空白界面，点击鼠标右键，弹出的菜单选择【options】，弹出如下的菜单界面，然后选择【Text】-&amp;gt;【Local】，然后在下拉菜单中选择zh_CN,在【Character set】下拉菜单中选择【utf-8】,最后点击apply，保存即可。
    
    </summary>
    
    
      <category term="git" scheme="https://phantomabyss.github.io/categories/git/"/>
    
    
      <category term="git" scheme="https://phantomabyss.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>内存分配与回收</title>
    <link href="https://phantomabyss.github.io/2019/11/26/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/"/>
    <id>https://phantomabyss.github.io/2019/11/26/jvm/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6/</id>
    <published>2019-11-26T11:03:05.000Z</published>
    <updated>2019-11-26T12:18:08.048Z</updated>
    
    <content type="html"><![CDATA[<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><blockquote><p>内存分配主要是在堆上(也有可能经过JIT编译器拆散为标量类型间接地在栈上分配)，对象主要分配在新生代的Eden上，如果启动了本地线程分配缓冲，则按线程优先在TLAB上分配。当时少数情况也可以直接分配在老年代中。</p></blockquote><h5 id="对象优先在Eden上分配"><a href="#对象优先在Eden上分配" class="headerlink" title="对象优先在Eden上分配"></a>对象优先在Eden上分配</h5><p>&emsp;1、多数情况下，对象在新生代Eden中分配<br>&emsp;2、Eden中内存不够时虚拟机就会发起一次Minor GC<br>&emsp;3、虚拟机提供-XX:+PrintGCDdtails告诉虚拟机在发生垃圾收集行为时，打印内存回收日志以及进程退出时内存各区域的分配情况。<br>&emsp;4、大对象直接进入老年代：大对象即大量连续内存空间的Java对象。如果经常出现大对象就需要内存还有没有使用的空间的时候就提前触发垃圾收集以获取足够的连续空间来安置。<br>&emsp;5、虚拟机提供了-XX:PretenureSizeThreshold参数(只对Serial和ParNew两款收集器有效)使大于设置值的对象直接在老年代分配，避免在Eden区以及两个Survivor区之间发生大量的内存复制。 —— 新生代采用复制算法收集。<br>&emsp;6、长期存活的对象将进入老年代：虚拟机给每个对象都定义了一个对象年龄计数器，如果对象在Eden出生后并经过一次Minor后仍然存活，并且能被Survivor容纳的话将被移到Survivor空间中，并且把计数器的值设为1，此后没熬过一岁，它的年龄就增加1，当增加到了一定的程度就会被晋升到老年代中，参数-XX:MaxTenuringThreshold可以设置晋升到老年代的阈值。<br>&emsp;7、动态对象年龄判定：如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。<br>&emsp;8、空间分配担保：进行Minor之前，需要检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则此次的Minor是安全的，如果不成立，虚拟机就会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，接着就会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，就会”冒险”进行一次Minor GC，如果小于，就不允许冒险，进行一次Full GC.</p><h5 id="Minor-GC-和-Full-GC"><a href="#Minor-GC-和-Full-GC" class="headerlink" title="Minor GC 和 Full GC"></a>Minor GC 和 Full GC</h5><p>&emsp;Minor GC:新生代GC，指发生在新生代的垃圾收集动作，大多数的Java对象都是朝生夕灭，因此Monitor GC非常频繁，一般回收速度也比较快。<br>&emsp;Full GC(Major GC):老年代GC，指发生在老年代的GC，出现了Full GC,经常会伴随至少一次Minor GC,Major GC的速度一般会比Minor GC慢1倍以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;内存分配&quot;&gt;&lt;a href=&quot;#内存分配&quot; class=&quot;headerlink&quot; title=&quot;内存分配&quot;&gt;&lt;/a&gt;内存分配&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;内存分配主要是在堆上(也有可能经过JIT编译器拆散为标量类型间接地在栈上分配)，对象主要分配在新生代的Eden上，如果启动了本地线程分配缓冲，则按线程优先在TLAB上分配。当时少数情况也可以直接分配在老年代中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;对象优先在Eden上分配&quot;&gt;&lt;a href=&quot;#对象优先在Eden上分配&quot; class=&quot;headerlink&quot; title=&quot;对象优先在Eden上分配&quot;&gt;&lt;/a&gt;对象优先在Eden上分配&lt;/h5&gt;&lt;p&gt;&amp;emsp;1、多数情况下，对象在新生代Eden中分配&lt;br&gt;&amp;emsp;2、Eden中内存不够时虚拟机就会发起一次Minor GC&lt;br&gt;&amp;emsp;3、虚拟机提供-XX:+PrintGCDdtails告诉虚拟机在发生垃圾收集行为时，打印内存回收日志以及进程退出时内存各区域的分配情况。&lt;br&gt;&amp;emsp;4、大对象直接进入老年代：大对象即大量连续内存空间的Java对象。如果经常出现大对象就需要内存还有没有使用的空间的时候就提前触发垃圾收集以获取足够的连续空间来安置。&lt;br&gt;&amp;emsp;5、虚拟机提供了-XX:PretenureSizeThreshold参数(只对Serial和ParNew两款收集器有效)使大于设置值的对象直接在老年代分配，避免在Eden区以及两个Survivor区之间发生大量的内存复制。 —— 新生代采用复制算法收集。&lt;br&gt;&amp;emsp;6、长期存活的对象将进入老年代：虚拟机给每个对象都定义了一个对象年龄计数器，如果对象在Eden出生后并经过一次Minor后仍然存活，并且能被Survivor容纳的话将被移到Survivor空间中，并且把计数器的值设为1，此后没熬过一岁，它的年龄就增加1，当增加到了一定的程度就会被晋升到老年代中，参数-XX:MaxTenuringThreshold可以设置晋升到老年代的阈值。&lt;br&gt;&amp;emsp;7、动态对象年龄判定：如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。&lt;br&gt;&amp;emsp;8、空间分配担保：进行Minor之前，需要检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果成立，则此次的Minor是安全的，如果不成立，虚拟机就会查看HandlePromotionFailure设置值是否允许担保失败，如果允许，接着就会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，就会”冒险”进行一次Minor GC，如果小于，就不允许冒险，进行一次Full GC.&lt;/p&gt;
&lt;h5 id=&quot;Minor-GC-和-Full-GC&quot;&gt;&lt;a href=&quot;#Minor-GC-和-Full-GC&quot; class=&quot;headerlink&quot; title=&quot;Minor GC 和 Full GC&quot;&gt;&lt;/a&gt;Minor GC 和 Full GC&lt;/h5&gt;&lt;p&gt;&amp;emsp;Minor GC:新生代GC，指发生在新生代的垃圾收集动作，大多数的Java对象都是朝生夕灭，因此Monitor GC非常频繁，一般回收速度也比较快。&lt;br&gt;&amp;emsp;Full GC(Major GC):老年代GC，指发生在老年代的GC，出现了Full GC,经常会伴随至少一次Minor GC,Major GC的速度一般会比Minor GC慢1倍以上。&lt;/p&gt;

    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集器</title>
    <link href="https://phantomabyss.github.io/2019/11/26/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://phantomabyss.github.io/2019/11/26/jvm/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</id>
    <published>2019-11-26T06:25:19.000Z</published>
    <updated>2019-11-26T12:48:30.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="收集器"><a href="#收集器" class="headerlink" title="收集器"></a>收集器</h3><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><blockquote><p>是一种以获取最短回收停顿时间为目标的收集器。</p></blockquote><ul><li>1、CMS收集器是基于标记-清楚算法实现的。</li><li>2、运作过程：<ul><li>1、初始标记：标记GC roots能直接关联的对象，速度快。</li><li>2、并发标记：进行GCTracing的过程</li><li>3、重新标记：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，停顿时间较初始标记稍长，较并发标记时间短。</li><li>4、并发清除</li></ul></li><li>3、并发标记和并发清除（耗时最长）过程都可以与用户线程一起并发执行。—— CMS收集器的内存回收过程是与用户线程一起并发执行的。</li><li>4、CMS收集器的缺点：<ul><li>1、CMS收集器对CPU资源非常敏感。(默认启动的回收线程数是(CPU数量 + 3)/4).解决办法：虚拟机提供了一种“增量式并发收集器”的CMS收集器变种(效果不明显，不值得提倡)。</li><li>2、CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败(CMS运行期间预留的内存无法满足用户程序的需要)而导致另一次Full GC的产生。<br>浮动垃圾：在标记过程之后产生的垃圾，只能等待下一次GC的时候再次回收这些垃圾。</li><li>3、手机结束后会有大量的碎片产生，无法找到足够大的连续空间给大对象分配内存，就需要提前触发一次Full GC。CMS收集器提供了<ul><li>-XX:+UserCMSCompactAtFullCollection参数解决该问题，用于在内存空间不够的时候需要进行Full GC的时候开启内存碎片的合并整理过程(无法并发)。</li><li>-XX:CMSFullGCsBeforeCompatction用于设置执行多少次不压缩的Full GC后，然后接着来一次压缩的。</li></ul></li></ul></li></ul><h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><blockquote><p>是以一款面向服务端应用的垃圾收集器。</p></blockquote><h5 id="G1收集器的特点"><a href="#G1收集器的特点" class="headerlink" title="G1收集器的特点"></a>G1收集器的特点</h5><p>&emsp;1、并行并发：利用多核CPU的硬件优势缩短停顿时间，原来执行GC动作需要停顿的java程序，G1可以并发让java程序继续执行。<br>&emsp;2、分代收集：采用不同的方式去处理新创建的对象以及已经存活了一段时间、熬过多次GC的旧对象。<br>&emsp;3、空间整合：G1整体是基于标记-整理算法实现的，局部是基于复制算法实现的，这就意味着G1在运行的时候不会产生大量的空间碎片，导致分配大对象时无法找到足够的内部直接开启下一次GC。<br>&emsp;4、可预测的停顿：通过建立可预测的停顿时间模型(避免在Java堆中进行全区域的垃圾收集)，能让使用者明确指定在一个长度为M毫秒的之间判断内，消耗在垃圾收集的时间不得超过N毫秒。</p><h5 id="G1收集器在内存区域的分布"><a href="#G1收集器在内存区域的分布" class="headerlink" title="G1收集器在内存区域的分布"></a>G1收集器在内存区域的分布</h5><p>&emsp;1、G1之前的收集器都将收集的范围分为整个新生代或者老年代。<br>&emsp;2、G1将Java堆的内存分为多个大小相等的独立区域，虽然还是保留到了新生代和老年代，但是它们之间不是隔离的了，而是一部分Region(不需要连续)的集合。<br>&emsp;3、G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，然后在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值更大的Region。<br>&emsp;4、G1中的Region之间的对象引用以及其他收集器之间老年代与新生代之间的对象引用都是通过Remembered Set来避免全堆扫描的。</p><h5 id="G1收集器的运作过程"><a href="#G1收集器的运作过程" class="headerlink" title="G1收集器的运作过程"></a>G1收集器的运作过程</h5><p>&emsp;1、初始标记:标记一下GC roots能直接关联的对象，并且修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region对象中创建新对象，此时需要停顿线程(时间很短)。<br>&emsp;2、并发标记：从GC roots中开始对Java堆中进行可达性分析，找出存活的对象，此时耗时较长(但是可以和用户程序并发执行)。<br>&emsp;3、最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的标记记录，虚拟机将这段变化的内容记录在线程Remembered Set logs中，最后将其合并到Remembered Set中，该阶段需要停顿线程，但是可以并行执行。<br>&emsp;4、筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户期望的GC停顿时间制定回收计划。</p><h5 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h5>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;收集器&quot;&gt;&lt;a href=&quot;#收集器&quot; class=&quot;headerlink&quot; title=&quot;收集器&quot;&gt;&lt;/a&gt;收集器&lt;/h3&gt;&lt;h4 id=&quot;CMS收集器&quot;&gt;&lt;a href=&quot;#CMS收集器&quot; class=&quot;headerlink&quot; title=&quot;CMS收集器&quot;&gt;&lt;/a&gt;CMS收集器&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;是一种以获取最短回收停顿时间为目标的收集器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;1、CMS收集器是基于标记-清楚算法实现的。&lt;/li&gt;
&lt;li&gt;2、运作过程：&lt;ul&gt;
&lt;li&gt;1、初始标记：标记GC roots能直接关联的对象，速度快。&lt;/li&gt;
&lt;li&gt;2、并发标记：进行GCTracing的过程&lt;/li&gt;
&lt;li&gt;3、重新标记：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录，停顿时间较初始标记稍长，较并发标记时间短。&lt;/li&gt;
&lt;li&gt;4、并发清除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;3、并发标记和并发清除（耗时最长）过程都可以与用户线程一起并发执行。—— CMS收集器的内存回收过程是与用户线程一起并发执行的。&lt;/li&gt;
&lt;li&gt;4、CMS收集器的缺点：&lt;ul&gt;
&lt;li&gt;1、CMS收集器对CPU资源非常敏感。(默认启动的回收线程数是(CPU数量 + 3)/4).解决办法：虚拟机提供了一种“增量式并发收集器”的CMS收集器变种(效果不明显，不值得提倡)。&lt;/li&gt;
&lt;li&gt;2、CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败(CMS运行期间预留的内存无法满足用户程序的需要)而导致另一次Full GC的产生。&lt;br&gt;浮动垃圾：在标记过程之后产生的垃圾，只能等待下一次GC的时候再次回收这些垃圾。&lt;/li&gt;
&lt;li&gt;3、手机结束后会有大量的碎片产生，无法找到足够大的连续空间给大对象分配内存，就需要提前触发一次Full GC。CMS收集器提供了&lt;ul&gt;
&lt;li&gt;-XX:+UserCMSCompactAtFullCollection参数解决该问题，用于在内存空间不够的时候需要进行Full GC的时候开启内存碎片的合并整理过程(无法并发)。&lt;/li&gt;
&lt;li&gt;-XX:CMSFullGCsBeforeCompatction用于设置执行多少次不压缩的Full GC后，然后接着来一次压缩的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;G1收集器&quot;&gt;&lt;a href=&quot;#G1收集器&quot; class=&quot;headerlink&quot; title=&quot;G1收集器&quot;&gt;&lt;/a&gt;G1收集器&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;是以一款面向服务端应用的垃圾收集器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;G1收集器的特点&quot;&gt;&lt;a href=&quot;#G1收集器的特点&quot; class=&quot;headerlink&quot; title=&quot;G1收集器的特点&quot;&gt;&lt;/a&gt;G1收集器的特点&lt;/h5&gt;&lt;p&gt;&amp;emsp;1、并行并发：利用多核CPU的硬件优势缩短停顿时间，原来执行GC动作需要停顿的java程序，G1可以并发让java程序继续执行。&lt;br&gt;&amp;emsp;2、分代收集：采用不同的方式去处理新创建的对象以及已经存活了一段时间、熬过多次GC的旧对象。&lt;br&gt;&amp;emsp;3、空间整合：G1整体是基于标记-整理算法实现的，局部是基于复制算法实现的，这就意味着G1在运行的时候不会产生大量的空间碎片，导致分配大对象时无法找到足够的内部直接开启下一次GC。&lt;br&gt;&amp;emsp;4、可预测的停顿：通过建立可预测的停顿时间模型(避免在Java堆中进行全区域的垃圾收集)，能让使用者明确指定在一个长度为M毫秒的之间判断内，消耗在垃圾收集的时间不得超过N毫秒。&lt;/p&gt;
&lt;h5 id=&quot;G1收集器在内存区域的分布&quot;&gt;&lt;a href=&quot;#G1收集器在内存区域的分布&quot; class=&quot;headerlink&quot; title=&quot;G1收集器在内存区域的分布&quot;&gt;&lt;/a&gt;G1收集器在内存区域的分布&lt;/h5&gt;&lt;p&gt;&amp;emsp;1、G1之前的收集器都将收集的范围分为整个新生代或者老年代。&lt;br&gt;&amp;emsp;2、G1将Java堆的内存分为多个大小相等的独立区域，虽然还是保留到了新生代和老年代，但是它们之间不是隔离的了，而是一部分Region(不需要连续)的集合。&lt;br&gt;&amp;emsp;3、G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，然后在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值更大的Region。&lt;br&gt;&amp;emsp;4、G1中的Region之间的对象引用以及其他收集器之间老年代与新生代之间的对象引用都是通过Remembered Set来避免全堆扫描的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>自动内存管理机制</title>
    <link href="https://phantomabyss.github.io/2019/11/21/jvm/%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/"/>
    <id>https://phantomabyss.github.io/2019/11/21/jvm/%E8%87%AA%E5%8A%A8%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98/</id>
    <published>2019-11-21T14:57:32.000Z</published>
    <updated>2019-11-26T10:26:00.513Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自动内存管理机制"><a href="#自动内存管理机制" class="headerlink" title="自动内存管理机制"></a>自动内存管理机制</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><ul><li><p>1、定义：给对象添加一个引用计数器，每当一个地方引用的时候，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的。</p></li><li><p>2、引用计数存在的问题(见以下的样例)：<br>  但是主流的Java虚拟机里面没有使用引用计数算法来管理内存，主要原因是因为引用计数算法很难解决对象之间相互循环引用的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoryManage;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个成员属性的作用的占点内存，以便在GC日志中看清楚是否被回收过</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">objA.instance = objB;</span><br><span class="line">objB.instance = objA;</span><br><span class="line"></span><br><span class="line">objA = <span class="keyword">null</span>;</span><br><span class="line">objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//GC</span></span><br><span class="line">System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ReferenceCountingGC.testGC();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5></li><li><p>1、定义：通过可达性分析来判断对象是否存活的。（Java、C#、Lisp）</p></li><li><p>2、算法思路：通过一系列称为“GC roots”的对象作为起始点，并以此节点向下搜索，搜索走过的路径为引用链，当一个对象到GC roots没有任何引用链时，则说明此对象是不可用的。</p></li><li><p>3、Java中可以作为GC roots的对象有：</p><ul><li>a、虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>b、方法区中类静态属性引用的对象。</li><li>c、方法区中常量引用的对象。</li><li>d、本地方法栈中JNI（Native方法）引用的对象。</li></ul></li></ul><h5 id="引用："><a href="#引用：" class="headerlink" title="引用："></a>引用：</h5><p>&emsp;<strong>强引用 &gt; 软引用 &gt; 弱引用 &gt; 虚引用</strong></p><ul><li>1、强引用：如“Object obj = new Object();”;只用强引用存在，垃圾收集器就不会回收被引用的对象。</li><li>2、软引用：描述一些还有用但并非必需的对象，在内存将要发生内存溢出之前，垃圾收集器会对这些对象进行二次回收（第一次回收已死的对象），如果这次回收内存还是不够，就会跑出内存溢出异常。(SoftReference类实现弱引用)</li><li>3、弱引用：描述一些非必需的对象，被弱引用关联的对象只能生存到下一次垃圾回收之前，无论内存是否足够使用，弱引用关联的对象都会被回收。(WeakReference类来实现弱引用)</li><li>4、虚引用：也称为幽灵引用或者幻影引用，虚引用不会对对象的生存时间造成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的目的是能在这个对象被垃圾收集器回收时收到一个系统通知。(PhantomReference类实现虚引用)</li></ul><h5 id="一个对象的死亡至少要经历两次标记过程"><a href="#一个对象的死亡至少要经历两次标记过程" class="headerlink" title="一个对象的死亡至少要经历两次标记过程:"></a>一个对象的死亡至少要经历两次标记过程:</h5><ul><li><p>1、如果对象在执行可达性分析后没有与GCroots相连的引用链，就会被打上第一次标记并且进行一次筛选，</p><pre><code>筛选条件是：此对象是否有必要执行finalize()方法。(当对象没有覆盖finalize()方法或者虚拟机之前已经调用过该方法了，虚拟机将这两种情况都当做“没有必要执行”)</code></pre></li><li><p>2、如果对象的finalize()方法有必要执行，则将其放入一个名为F-Queue的队列中，稍后由一个Finalizer线程(虚拟机自动建立、低优先级)去执行它——既虚拟机会触发这个方法执行，但是不会等待它执行结束(防止finalize()方法执行缓慢或者陷入死循环)</p></li><li><p>3、如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关系，那么在第二次标记的时候就被移出即将回收的集合。否则就被垃圾收集器回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoryManage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以下代码的作用：</span></span><br><span class="line"><span class="comment"> * 1、对象可以再被GC时自我拯救</span></span><br><span class="line"><span class="comment"> * 2、但是只可以自救一次，因为一个对象的finalize()方法只会被虚拟机调用一次</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"yes,I am still alive;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.finalize();</span><br><span class="line">System.out.println(<span class="string">"finalize method executed"</span>);</span><br><span class="line">FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象第一次拯救自己</span></span><br><span class="line">SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">//finalize方法的优先级较低，暂停0.5秒以等待它</span></span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"no,I am dead;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面的代码与上面是一致的，但是这次自救会失败</span></span><br><span class="line"><span class="comment"> * 因为任何一个对象的finalize方法只会被系统自动调用一次</span></span><br><span class="line"><span class="comment"> * 如果该对象下次再次被回收时，finalize方法就不会再次执行了，自救也就失败了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">System.gc();</span><br><span class="line"><span class="comment">//finalize方法的优先级比较低，暂停0.5秒等地</span></span><br><span class="line">Thread.sleep(<span class="number">500</span>);</span><br><span class="line"><span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">SAVE_HOOK.isAlive();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"no,I am dead"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="回收方法区：回收的效率很低，主要回收废弃常量和无用的类。"><a href="#回收方法区：回收的效率很低，主要回收废弃常量和无用的类。" class="headerlink" title="回收方法区：回收的效率很低，主要回收废弃常量和无用的类。"></a>回收方法区：回收的效率很低，主要回收废弃常量和无用的类。</h5><h6 id="无用的类需要满足的条件："><a href="#无用的类需要满足的条件：" class="headerlink" title="无用的类需要满足的条件："></a>无用的类需要满足的条件：</h6><ul><li>1、该类所有的实例都已经被回收，java堆中不存在该类的任何实例。</li><li>2、加载该类的ClassLoader已经被回收</li><li>3、该类对象的java.lang.Class对象没有在任何地方被引用，无法再任何地方通过反射访问该类的方法。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;自动内存管理机制&quot;&gt;&lt;a href=&quot;#自动内存管理机制&quot; class=&quot;headerlink&quot; title=&quot;自动内存管理机制&quot;&gt;&lt;/a&gt;自动内存管理机制&lt;/h4&gt;&lt;h5 id=&quot;引用计数算法&quot;&gt;&lt;a href=&quot;#引用计数算法&quot; class=&quot;headerlink&quot; title=&quot;引用计数算法&quot;&gt;&lt;/a&gt;引用计数算法&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、定义：给对象添加一个引用计数器，每当一个地方引用的时候，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能在被使用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、引用计数存在的问题(见以下的样例)：&lt;br&gt;  但是主流的Java虚拟机里面没有使用引用计数算法来管理内存，主要原因是因为引用计数算法很难解决对象之间相互循环引用的问题。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; memoryManage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ReferenceCountingGC&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object instance = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; _1MB = &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt; * &lt;span class=&quot;number&quot;&gt;1024&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 * 这个成员属性的作用的占点内存，以便在GC日志中看清楚是否被回收过&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;	 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[] bigSize = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; * _1MB];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;testGC&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ReferenceCountingGC objA = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReferenceCountingGC();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ReferenceCountingGC objB = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ReferenceCountingGC();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		objA.instance = objB;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		objB.instance = objA;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		objA = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		objB = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//GC&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.gc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		ReferenceCountingGC.testGC();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;可达性分析算法&quot;&gt;&lt;a href=&quot;#可达性分析算法&quot; class=&quot;headerlink&quot; title=&quot;可达性分析算法&quot;&gt;&lt;/a&gt;可达性分析算法&lt;/h5&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;1、定义：通过可达性分析来判断对象是否存活的。（Java、C#、Lisp）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、算法思路：通过一系列称为“GC roots”的对象作为起始点，并以此节点向下搜索，搜索走过的路径为引用链，当一个对象到GC roots没有任何引用链时，则说明此对象是不可用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3、Java中可以作为GC roots的对象有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a、虚拟机栈（栈帧中的本地变量表）中引用的对象。&lt;/li&gt;
&lt;li&gt;b、方法区中类静态属性引用的对象。&lt;/li&gt;
&lt;li&gt;c、方法区中常量引用的对象。&lt;/li&gt;
&lt;li&gt;d、本地方法栈中JNI（Native方法）引用的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;引用：&quot;&gt;&lt;a href=&quot;#引用：&quot; class=&quot;headerlink&quot; title=&quot;引用：&quot;&gt;&lt;/a&gt;引用：&lt;/h5&gt;&lt;p&gt;&amp;emsp;&lt;strong&gt;强引用 &amp;gt; 软引用 &amp;gt; 弱引用 &amp;gt; 虚引用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、强引用：如“Object obj = new Object();”;只用强引用存在，垃圾收集器就不会回收被引用的对象。&lt;/li&gt;
&lt;li&gt;2、软引用：描述一些还有用但并非必需的对象，在内存将要发生内存溢出之前，垃圾收集器会对这些对象进行二次回收（第一次回收已死的对象），如果这次回收内存还是不够，就会跑出内存溢出异常。(SoftReference类实现弱引用)&lt;/li&gt;
&lt;li&gt;3、弱引用：描述一些非必需的对象，被弱引用关联的对象只能生存到下一次垃圾回收之前，无论内存是否足够使用，弱引用关联的对象都会被回收。(WeakReference类来实现弱引用)&lt;/li&gt;
&lt;li&gt;4、虚引用：也称为幽灵引用或者幻影引用，虚引用不会对对象的生存时间造成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的目的是能在这个对象被垃圾收集器回收时收到一个系统通知。(PhantomReference类实现虚引用)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;一个对象的死亡至少要经历两次标记过程&quot;&gt;&lt;a href=&quot;#一个对象的死亡至少要经历两次标记过程&quot; class=&quot;headerlink&quot; title=&quot;一个对象的死亡至少要经历两次标记过程:&quot;&gt;&lt;/a&gt;一个对象的死亡至少要经历两次标记过程:&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、如果对象在执行可达性分析后没有与GCroots相连的引用链，就会被打上第一次标记并且进行一次筛选，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;筛选条件是：此对象是否有必要执行finalize()方法。(当对象没有覆盖finalize()方法或者虚拟机之前已经调用过该方法了，虚拟机将这两种情况都当做“没有必要执行”)&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、如果对象的finalize()方法有必要执行，则将其放入一个名为F-Queue的队列中，稍后由一个Finalizer线程(虚拟机自动建立、低优先级)去执行它——既虚拟机会触发这个方法执行，但是不会等待它执行结束(防止finalize()方法执行缓慢或者陷入死循环)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3、如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关系，那么在第二次标记的时候就被移出即将回收的集合。否则就被垃圾收集器回收。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; memoryManage;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 以下代码的作用：&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 	1、对象可以再被GC时自我拯救&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * 	2、但是只可以自救一次，因为一个对象的finalize()方法只会被虚拟机调用一次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@author&lt;/span&gt; Administrator&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; *&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;FinalizeEscapeGC&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; FinalizeEscapeGC SAVE_HOOK = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;isAlive&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;yes,I am still alive;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;finalize&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.finalize();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;finalize method executed&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		FinalizeEscapeGC.SAVE_HOOK = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		SAVE_HOOK = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FinalizeEscapeGC();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//对象第一次拯救自己&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		SAVE_HOOK = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.gc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//finalize方法的优先级较低，暂停0.5秒以等待它&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Thread.sleep(&lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(SAVE_HOOK != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			SAVE_HOOK.isAlive();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;no,I am dead;&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;		 * 下面的代码与上面是一致的，但是这次自救会失败&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;		 * 因为任何一个对象的finalize方法只会被系统自动调用一次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;		 * 如果该对象下次再次被回收时，finalize方法就不会再次执行了，自救也就失败了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;		 */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		SAVE_HOOK = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		System.gc();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//finalize方法的优先级比较低，暂停0.5秒等地&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Thread.sleep(&lt;span class=&quot;number&quot;&gt;500&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(SAVE_HOOK != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			SAVE_HOOK.isAlive();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;no,I am dead&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&quot;回收方法区：回收的效率很低，主要回收废弃常量和无用的类。&quot;&gt;&lt;a href=&quot;#回收方法区：回收的效率很低，主要回收废弃常量和无用的类。&quot; class=&quot;headerlink&quot; title=&quot;回收方法区：回收的效率很低，主要回收废弃常量和无用的类。&quot;&gt;&lt;/a&gt;回收方法区：回收的效率很低，主要回收废弃常量和无用的类。&lt;/h5&gt;&lt;h6 id=&quot;无用的类需要满足的条件：&quot;&gt;&lt;a href=&quot;#无用的类需要满足的条件：&quot; class=&quot;headerlink&quot; title=&quot;无用的类需要满足的条件：&quot;&gt;&lt;/a&gt;无用的类需要满足的条件：&lt;/h6&gt;
    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域</title>
    <link href="https://phantomabyss.github.io/2019/11/16/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
    <id>https://phantomabyss.github.io/2019/11/16/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</id>
    <published>2019-11-16T14:29:23.000Z</published>
    <updated>2019-11-22T12:01:10.093Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java虚拟机内存的各个区域"><a href="#Java虚拟机内存的各个区域" class="headerlink" title="Java虚拟机内存的各个区域"></a>Java虚拟机内存的各个区域</h4><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a><strong><em>程序计数器</em></strong></h5><blockquote><p>当前线程的所执行的字节码的行号指示器——线程私有的内存</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>、Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的。——每个线程都有一个独立的程序计数器，线程之间互不影响。</span><br><span class="line">* <span class="number">2</span>、线程执行Java方法时：程序计数器记录正在执行的虚拟机字节码指令的地址。</span><br><span class="line">* <span class="number">3</span>、线程执行Native方法时：计数器的值为空（Undefined）。</span><br></pre></td></tr></table></figure><h5 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a><strong><em>Java虚拟机栈</em></strong></h5><blockquote><p>描述的是Java方法执行的内存模型——线程私有的内存。<br>生命周期与线程相同</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>、每个方法在执行的同时都会创建一个栈帧用于存储局部变量表(栈内存)、操作数栈、动态链接、方法出口等信息。</span><br><span class="line">* <span class="number">2</span>、局部变量表存储八种基本数据类型(*<span class="built_in">bool</span>ean,byte,char,short,<span class="built_in">int</span>,<span class="built_in">float</span>,<span class="built_in">double</span>,long*)、对象引用类型(*<span class="built_in">ref</span>erence*类型)、*returnAddress*类型。</span><br><span class="line">   * <span class="built_in">ref</span>erence类型：可能是一个指向对象起始地址的引用指针，也可能是一个指向一个代表对象的句柄或其他与此对象相关的位置。</span><br><span class="line">* <span class="number">3</span>、$调用\stackrel&#123;方法&#125;&#123;\longrightarrow&#125;完成\stackrel&#123;等价于&#125;&#123;\Longrightarrow&#125;入栈\stackrel&#123;栈帧&#125;&#123;\longrightarrow&#125;出栈(虚拟机栈)$</span><br><span class="line">* <span class="number">4</span>、局部变量表所需的内存空间在编译期间完成分配，运行期间不会改变。</span><br><span class="line">* <span class="number">5</span>、Java虚拟机对该区域定义的两种异常规范：</span><br><span class="line">  * <span class="number">1</span>、线程请求的栈深度大于虚拟机所允许的深度。——*StackOverflowError*</span><br><span class="line">  * <span class="number">2</span>、若虚拟机支持扩展后任然无法申请到足够的内存。——*OutofMemeoryError*</span><br></pre></td></tr></table></figure><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a><strong><em>本地方法栈</em></strong></h5><blockquote><p>为虚拟机使用的Native方法服务，具体的虚拟机可以对其自由实现。</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>、HotSpot将本地方法栈与虚拟机栈合二为一了。</span><br><span class="line">* <span class="number">2</span>、本地方法栈的两种异常规范与虚拟机栈相同。</span><br></pre></td></tr></table></figure><h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a><strong><em>Java堆</em></strong></h5><blockquote><p>是被所有线程共享的一块内存区域，在虚拟机启动时创建，存放对象实例，分配内存</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 1、所有的对象实例以及数组都要在堆上分配内存。</span><br><span class="line">* 2、随着JIT编译器和逃逸分析技术的发展：<span class="formula">$$ <span class="tag">\<span class="name">left</span></span><span class="tag">\<span class="name">&#123;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">begin</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula">栈上分配 <span class="tag">\<span class="name">\</span></span></span></span><br><span class="line"><span class="formula">标量替换优先技术</span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">end</span><span class="string">&#123;aligned&#125;</span></span></span></span><br><span class="line"><span class="formula"><span class="tag">\<span class="name">right</span></span>.</span></span><br><span class="line"><span class="formula">$$</span>会发生一些变化。</span><br><span class="line">* 3、是垃圾收集器管理的主要区域——都采用分代收集算法(新生代，老年代)。</span><br></pre></td></tr></table></figure><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a><strong><em>方法区</em></strong></h5><blockquote><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译、编译后的代码等数据。是各个线程共享的区域。——永久代</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* <span class="number">1</span>、不需要选择一块连续的内存或可以选择固定大小或可扩展。</span><br><span class="line">* <span class="number">2.</span>还可以选择不实现垃圾收集</span><br><span class="line">* <span class="number">3</span>、该区域的内存回收主要是针对常量池的回收和对类型的卸载。</span><br></pre></td></tr></table></figure><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a><strong><em>运行时常量池</em></strong></h5><blockquote><p>Class文件中的一项信息时常量池，用于存放编译期生成的各种字面量和符号引用，这些内容在类加载中</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Java虚拟机内存的各个区域&quot;&gt;&lt;a href=&quot;#Java虚拟机内存的各个区域&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机内存的各个区域&quot;&gt;&lt;/a&gt;Java虚拟机内存的各个区域&lt;/h4&gt;&lt;h5 id=&quot;程序计数器&quot;&gt;&lt;a href=&quot;#程序计数器&quot; class=&quot;headerlink&quot; title=&quot;程序计数器&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;程序计数器&lt;/em&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;当前线程的所执行的字节码的行号指示器——线程私有的内存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间来实现的。——每个线程都有一个独立的程序计数器，线程之间互不影响。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、线程执行Java方法时：程序计数器记录正在执行的虚拟机字节码指令的地址。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;、线程执行Native方法时：计数器的值为空（Undefined）。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;Java虚拟机栈&quot;&gt;&lt;a href=&quot;#Java虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;Java虚拟机栈&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;Java虚拟机栈&lt;/em&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;描述的是Java方法执行的内存模型——线程私有的内存。&lt;br&gt;生命周期与线程相同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、每个方法在执行的同时都会创建一个栈帧用于存储局部变量表(栈内存)、操作数栈、动态链接、方法出口等信息。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、局部变量表存储八种基本数据类型(*&lt;span class=&quot;built_in&quot;&gt;bool&lt;/span&gt;ean,byte,char,short,&lt;span class=&quot;built_in&quot;&gt;int&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;float&lt;/span&gt;,&lt;span class=&quot;built_in&quot;&gt;double&lt;/span&gt;,long*)、对象引用类型(*&lt;span class=&quot;built_in&quot;&gt;ref&lt;/span&gt;erence*类型)、*returnAddress*类型。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   * &lt;span class=&quot;built_in&quot;&gt;ref&lt;/span&gt;erence类型：可能是一个指向对象起始地址的引用指针，也可能是一个指向一个代表对象的句柄或其他与此对象相关的位置。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;、$调用\stackrel&amp;#123;方法&amp;#125;&amp;#123;\longrightarrow&amp;#125;完成\stackrel&amp;#123;等价于&amp;#125;&amp;#123;\Longrightarrow&amp;#125;入栈\stackrel&amp;#123;栈帧&amp;#125;&amp;#123;\longrightarrow&amp;#125;出栈(虚拟机栈)$&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;、局部变量表所需的内存空间在编译期间完成分配，运行期间不会改变。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;、Java虚拟机对该区域定义的两种异常规范：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、线程请求的栈深度大于虚拟机所允许的深度。——*StackOverflowError*&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、若虚拟机支持扩展后任然无法申请到足够的内存。——*OutofMemeoryError*&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;本地方法栈&quot;&gt;&lt;a href=&quot;#本地方法栈&quot; class=&quot;headerlink&quot; title=&quot;本地方法栈&quot;&gt;&lt;/a&gt;&lt;strong&gt;&lt;em&gt;本地方法栈&lt;/em&gt;&lt;/strong&gt;&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;为虚拟机使用的Native方法服务，具体的虚拟机可以对其自由实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight angelscript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、HotSpot将本地方法栈与虚拟机栈合二为一了。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、本地方法栈的两种异常规范与虚拟机栈相同。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="深入理解Java虚拟机" scheme="https://phantomabyss.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="https://phantomabyss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>解决每次部署到GitHub时都需要输入用户名和密码的问题</title>
    <link href="https://phantomabyss.github.io/2019/09/27/hexo/%E8%A7%A3%E5%86%B3%E9%83%A8%E7%BD%B2%E6%97%B6%E6%AF%8F%E6%AC%A1%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://phantomabyss.github.io/2019/09/27/hexo/%E8%A7%A3%E5%86%B3%E9%83%A8%E7%BD%B2%E6%97%B6%E6%AF%8F%E6%AC%A1%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2019-09-27T15:17:37.000Z</published>
    <updated>2020-05-15T09:59:33.799Z</updated>
    
    <content type="html"><![CDATA[<p>对于每次使用git bash部署博客到GitHub都需要输入用户名和密码，总觉得很烦，经过在网上查找的一些资料和自己一些理解记录一哈过程，便于以后查询。</p><a id="more"></a><p><strong>前提：<br>    &emsp;使用ssh连接的方式可以避免每次部署项目的时候需要输入用户名和密码的过程，同时也比较安全。</strong></p><ul><li><strong>1、配置ssh密钥</strong><br><del>如果已经在GitHub配置ssh密钥，可以跳过</del><ul><li>1.1、生成ssh密钥对<ul><li>1.1.1、查看自己是否已经生成了ssh密钥对,如果没有，文件夹为空。<img src="/images/hexo/ssh.jpg"></li><li>1.1.2、在git bash命令行执行以下命令,建议在生成密钥的过程中不要输入用户名和密码，否则后面就需要其他的配置，一路回车就行了，执行完成后就会生成对应的密钥文件。<img src="/images/hexo/getssh.jpg"><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -<span class="built_in">t</span> rsa -C 你的GitHub对应的邮箱</span><br></pre></td></tr></table></figure><img src="/images/hexo/isapub.jpg">.pub后缀的文件就是你的公钥</li></ul></li><li>1.2、在GitHub上添加公钥<br>  将上面.pub文件的内容复制到github的ssh keys(头像处的settings-&gt;SSH and GPG keys-&gt;New SSH key)处，title可以随便取。  <img src="/images/hexo/sshkeys.jpg"></li></ul></li><li><strong>2、修改站点目录配置文件</strong><ul><li>2.1、修改_config.yml文件，将部署方式从https方式修改为ssh，直接打开_config.yml搜索deployment即可<img src="/images/hexo/deployment.jpg"></li><li>2.2、接下来直接在hexo的根目录下打开git bash命令行执行以下两条命令即可<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"username"</span>    <span class="comment"># GitHub的用户名</span></span><br><span class="line">$ git config --global user.email <span class="string">"yourEmail"</span>  <span class="comment"># GitHub注册时你输入的邮箱</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong>3、重新部署hexo到GitHub</strong><br>  重新打开git bash命令行再次部署到GitHub即可</li></ul><p>到这里我的就行了，建议你们可以去试试。如果问题还没有解决，可以参考原博文的方法。</p><p>以上内容参考于：<br>    <a href="https://zhidao.baidu.com/question/2121621163479338627.html" target="_blank" rel="noopener">为什么hexo用git部署到github上每次都要输入用户名和密码</a><br>    <a href="https://www.cnblogs.com/yaoel/p/5381826.html" target="_blank" rel="noopener">使用Github SSH Key来避免Hexo部署时输入账户密码</a><br>    <a href="https://blog.csdn.net/jinmie0193/article/details/81589661" target="_blank" rel="noopener">github设置SSH登陆</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于每次使用git bash部署博客到GitHub都需要输入用户名和密码，总觉得很烦，经过在网上查找的一些资料和自己一些理解记录一哈过程，便于以后查询。&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://phantomabyss.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://phantomabyss.github.io/tags/hexo/"/>
    
      <category term="GitHub" scheme="https://phantomabyss.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客部署到GitHub</title>
    <link href="https://phantomabyss.github.io/2019/09/20/hexo/hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E5%8D%9A%E5%AE%A2/"/>
    <id>https://phantomabyss.github.io/2019/09/20/hexo/hexo%E9%83%A8%E7%BD%B2%E5%88%B0%E5%8D%9A%E5%AE%A2/</id>
    <published>2019-09-20T02:42:16.000Z</published>
    <updated>2020-05-15T10:03:25.832Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了一下hexo博客部署到GitHub上的步骤</p><a id="more"></a><ul><li><strong>1、新建GitHub仓库</strong><ul><li>1.1、登录到自己的<a href="https://github.com" target="_blank" rel="noopener">GitHub</a>中，新建一个名为$你的用户名.github.io(如phantomAbyss.github.io)$的仓库，<img src="/images/hexo/createRepository.jpg"></li><li>1.2、然后创建成功后，在Settings往下翻找到GitHub Pages打勾，不然后面访问不了<br><img src="/images/hexo/settings.jpg"><img src="/images/hexo/githubPages.jpg"></li><li>1.3、复制刚建的仓库的git地址<img src="/images/hexo/address.jpg"></li></ul></li><li><strong>2、修改本地hexo的配置文件</strong><ul><li>2.1、首先进入自己的blog目录(即站点目录，我的命名是hexo)，打开该目录下的.config.yml文件<img src="/images/hexo/hexo.jpg"></li><li>2.2、直接在_config.yml文件搜索deploy,可以找到如下图所示的内容  <img src="/images/hexo/deploy.jpg">  然后按照下面的描述修改即可。  ***注意：      1.每个冒号后面都有一个空格      2.repo的命令必须严格按照要求命名***  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>: git</span><br><span class="line"><span class="comment"># 下面两种形式的地址任选一种</span></span><br><span class="line">repo: https://github.com/GitHub用户名/GitHub用户名.github.io.git</span><br><span class="line"><span class="comment"># repo: git@github.com:GitHub用户名/GitHub用户名.github.io.git</span></span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>3、安装部署博客的插件</strong><ul><li>3.1、在站点目录打开git bash命令行执行命令(我是hexo目录)  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>  <img src="/images/hexo/hexo-deployer.jpg"></li><li>3.2、配置ssh,如果之前已配置，可以直接跳过</li><li>3.3、使用命令$hexo d(hexo deploy)$即可成功部署博客</li></ul></li><li><strong>4、浏览效果</strong><ul><li>4.1、最后直接在浏览器输入(https://你的GitHub的用户名.github.io)即可访问你的博客主页了</li><li>4.2、<a href="https://phantomabyss.github.io/">幻影</a>，这是我的博客，欢迎大家来踩踩。<br/>到这里就差不多结束了。。。。。</li></ul></li></ul><hr><p>最后再说说对于<strong>每次执行hexo d命令时都需要输入账号和密码</strong>的问题，可以参考另一篇博客<a href="https://phantomabyss.github.io/2019/09/27/hexo/%E8%A7%A3%E5%86%B3%E9%83%A8%E7%BD%B2%E6%97%B6%E6%AF%8F%E6%AC%A1%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E7%9A%84%E9%97%AE%E9%A2%98/">解决每次部署到GitHub时都需要输入用户名和密码的问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了一下hexo博客部署到GitHub上的步骤&lt;/p&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="https://phantomabyss.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://phantomabyss.github.io/tags/hexo/"/>
    
      <category term="GitHub" scheme="https://phantomabyss.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>hexo如何删除文章</title>
    <link href="https://phantomabyss.github.io/2019/09/20/hexo/hexo%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0/"/>
    <id>https://phantomabyss.github.io/2019/09/20/hexo/hexo%E4%B8%AD%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%96%87%E7%AB%A0/</id>
    <published>2019-09-20T02:28:45.000Z</published>
    <updated>2020-05-15T10:24:12.582Z</updated>
    
    <content type="html"><![CDATA[<ul><li>1、首先找到blog/source/_posts目录下的需要删除的MarkDown文件，然后将其删除</li><li>2.然后在打开git bash命令界面，执行以下命令<a id="more"></a>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g <span class="comment"># 全称为：hexo generate 生成静态页面</span></span><br><span class="line">hexo s <span class="comment"># hexo server   查看本地效果</span></span><br></pre></td></tr></table></figure></li><li>2、提交到GitHub  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g <span class="comment"># 全称为：hexo generate 生成静态页面</span></span><br><span class="line">hexo s <span class="comment"># hexo server   查看本地效果</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>注意</strong><br>&emsp;source/_posts目录下一定还要有另一个markdown文件，不然删除文章就不会有效</p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;1、首先找到blog/source/_posts目录下的需要删除的MarkDown文件，然后将其删除&lt;/li&gt;
&lt;li&gt;2.然后在打开git bash命令界面，执行以下命令
    
    </summary>
    
    
      <category term="hexo" scheme="https://phantomabyss.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="https://phantomabyss.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>当你越来越沉默，越来越不想说</title>
    <link href="https://phantomabyss.github.io/2019/09/20/phantom/%E6%B2%89%E9%BB%98/"/>
    <id>https://phantomabyss.github.io/2019/09/20/phantom/%E6%B2%89%E9%BB%98/</id>
    <published>2019-09-20T02:25:32.000Z</published>
    <updated>2019-10-05T07:39:52.150Z</updated>
    
    <content type="html"><![CDATA[<p>网上有这么一句话：“沉默，是一个人最大的哭声”。意思是说，人之所以沉默，是被生活抹去了棱角，是对世界的一种妥协，是一件很可悲的事情。<br>我却觉得，如果你越来越沉默，越来越不想说，这不是懦弱，不是妥协，而是意味着，你看淡了很多的事，看轻了很多人，你变得越来越成熟。<br>明亮而不刺眼，柔软却很有力量。</p><p><front color="blue">把人看清，不如把人看轻。</front><br>年轻的时候，特别喜欢与人争辩，特别在乎别人对自己的看法，遇到点芝麻大的事情也喜欢找人诉苦。<br>后来，慢慢长大，发现越来越喜欢沉默的感觉。<br>不在急着与人辩驳自己的看法，逐渐明白，不是所有人都生活在同一片海里，经历不同，三观不同，对一件事的看法也一定会有所不同。<br>道同则同行一段，道不同则不相为谋。<br>不再把自己所有的喜怒哀乐都寄托在别人的身上。<br>觉得跟谁在一起舒服，就多多交往，如果觉得累了，选择沉默，慢慢远离便是。<br>生活已经如此艰难，没必要强求自己去取悦谁，迎合谁。<br>生活里有了苦，也不再急哄哄地找人诉苦。<br>因为自己苦，只有自己懂。<br>说的多了，只有自己懂。<br>说的多了，别人只会觉得你矫情，不如找一个安静的角落，找一件令自己开心的事情，独自疗伤，寂静欢喜。<br>人这一生，终究会遇见许多人，而每一个出现在你生命的人，都有其意义。<br>爱你的人，给你温暖与勇气；<br>你爱的人，让你学会如果爱与分享；<br>你不喜欢的人，教会你如何宽容和尊重；<br>不喜欢你的人，让你学会自省和成长。<br>人生就像一场旅行，有的人在这一站下车，有的人在下一站下车，能同行一程，已是莫大的缘分。<br>当陪你的人要离开时，即使不舍也该心存感激，学着看轻，然后挥手道别。<br>我们都是天地间的过客，世上很多人和事，我们都做不了主。<br>山和水可以两两相忘，日与月可以毫无瓜葛。<br>红尘陌上，我们重要独自行走，看轻了，人才会更快乐</p><p>把事看透，不如把事看淡。<br>半生已过，你越来越沉默，不过是明白了很多事情并没有自己想象中的那么重要，想一想，就算了，于是选择了沉默。<br>很久之前，一位国王想找一句话，这句话要使高兴的人听了难过，难过的人听了高兴。<br>但他花很多时间问了很多人，都没有找到。<br>直到有一天夜里，在梦中有一位智者对他说了一句话：“这一切都会过去的！”；<br>世事如烟，沧海桑田，不管是好的还是坏的，没有一件事是永恒不变的。<br>对于那些看不透的，难以放下的事情，沉默是最好的武器，时间是最好的解药，会让一切过去。<br>不知道从什么时候开始，我疯狂地喜欢上了这句话：“宠辱不惊，闲看庭前花开花落，去留无意，漫随天外云卷云舒。”<br>它几乎成了我的人生箴言，每当我伤心难过，被人误解，工作不顺的时候，我就会用这句话来勉励自己；<br>人生数十载，我们现在所在意的，计较的，已得的，不过是生命长河里非常短暂的一瞬，几年或者十几年后在回过头来看，一切都是过眼云烟，完全不值得我们耿耿于怀。<br>往后余生，告诉自己，得也开心，失也淡定，看淡生命中发生的每一件事沉默安静，浅笑安然。<br>相信很多人都有这样的经历：<br>很喜欢在QQ空间里发表说说，或者发朋友圈，用简单的几句话，表达一些自己当时的所见所感，或者一些别人不易察觉的小心思。<br>等到多年之后，再去翻曾经发的说说，朋友圈，会觉得自己曾经的言论很矫情，恨不得全部删除。<br>其实，这就是生活的本质，不管当初多么欢喜，在意，随着时间的流逝，一切都会慢慢变淡，成了你生命中里一段缥缈的记忆。<br>所以，你越来越沉默，越来越不喜欢在人前表现自己，越来越深刻地明白；<br>爱过恨过，皆成经过，好事坏事，终成往事。<br>把心放宽，把事看淡，在沉默中独享自己的小心事，就是最好的生活方式。</p><p>喜欢沉默，不过是因为越来越成熟。<br>看过这么一句话：<br>“没人会在乎你怎样在深夜里痛哭，也没人在乎你要辗转反侧的要熬过几个秋，外人只看结果，自己独撑过程”<br>等你明白了这个道理，便不会在人前矫情，<br>四处诉说以求宽慰。<br>当你越来越沉默，越来越不想说，应该是你越来越成熟，很多是看淡了，很多看轻了。<br>所以，当想争辩的时候，想一想，就算了，于是选择了沉默。<br>也不再像年少的时候那样，时时想着融入别人的世界。<br>年岁渐长，慢慢喜欢上安静和独处。<br>闲来无事，给自己和家人准备一顿精致的餐点。<br>打扫屋子，摆上自己买来的好看的小物件；<br>带着耳机，听着喜欢的音乐在公园里散步；<br>捧一本书，安静地呆一个下午。。。。。<br>如果你远远地看见一个人，端坐一隅，浅笑安然，不喧嚣，不张扬，他并没有不开心，只是觉得，沉默的状态，更舒服。<br>一个在聪明，也不能事事都看透；一个在智慧，也不能人人都看懂。<br>真正成熟的人，明白往事如流，人生最好的状态，不是避开车马喧嚣，而是在心中修篱种菊。<br>往后余生，愿你不争不抢，不闹不恼，不卑不亢，沉默以对，寂静欢喜。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上有这么一句话：“沉默，是一个人最大的哭声”。意思是说，人之所以沉默，是被生活抹去了棱角，是对世界的一种妥协，是一件很可悲的事情。&lt;br&gt;我却觉得，如果你越来越沉默，越来越不想说，这不是懦弱，不是妥协，而是意味着，你看淡了很多的事，看轻了很多人，你变得越来越成熟。&lt;br&gt;明亮而不刺眼，柔软却很有力量。&lt;/p&gt;
&lt;p&gt;&lt;front color=&quot;blue&quot;&gt;把人看清，不如把人看轻。&lt;/front&gt;&lt;br&gt;年轻的时候，特别喜欢与人争辩，特别在乎别人对自己的看法，遇到点芝麻大的事情也喜欢找人诉苦。&lt;br&gt;后来，慢慢长大，发现越来越喜欢沉默的感觉。&lt;br&gt;不在急着与人辩驳自己的看法，逐渐明白，不是所有人都生活在同一片海里，经历不同，三观不同，对一件事的看法也一定会有所不同。&lt;br&gt;道同则同行一段，道不同则不相为谋。&lt;br&gt;不再把自己所有的喜怒哀乐都寄托在别人的身上。&lt;br&gt;觉得跟谁在一起舒服，就多多交往，如果觉得累了，选择沉默，慢慢远离便是。&lt;br&gt;生活已经如此艰难，没必要强求自己去取悦谁，迎合谁。&lt;br&gt;生活里有了苦，也不再急哄哄地找人诉苦。&lt;br&gt;因为自己苦，只有自己懂。&lt;br&gt;说的多了，只有自己懂。&lt;br&gt;说的多了，别人只会觉得你矫情，不如找一个安静的角落，找一件令自己开心的事情，独自疗伤，寂静欢喜。&lt;br&gt;人这一生，终究会遇见许多人，而每一个出现在你生命的人，都有其意义。&lt;br&gt;爱你的人，给你温暖与勇气；&lt;br&gt;你爱的人，让你学会如果爱与分享；&lt;br&gt;你不喜欢的人，教会你如何宽容和尊重；&lt;br&gt;不喜欢你的人，让你学会自省和成长。&lt;br&gt;人生就像一场旅行，有的人在这一站下车，有的人在下一站下车，能同行一程，已是莫大的缘分。&lt;br&gt;当陪你的人要离开时，即使不舍也该心存感激，学着看轻，然后挥手道别。&lt;br&gt;我们都是天地间的过客，世上很多人和事，我们都做不了主。&lt;br&gt;山和水可以两两相忘，日与月可以毫无瓜葛。&lt;br&gt;红尘陌上，我们重要独自行走，看轻了，人才会更快乐&lt;/p&gt;
&lt;p&gt;把事看透，不如把事看淡。&lt;br&gt;半生已过，你越来越沉默，不过是明白了很多事情并没有自己想象中的那么重要，想一想，就算了，于是选择了沉默。&lt;br&gt;很久之前，一位国王想找一句话，这句话要使高兴的人听了难过，难过的人听了高兴。&lt;br&gt;但他花很多时间问了很多人，都没有找到。&lt;br&gt;直到有一天夜里，在梦中有一位智者对他说了一句话：“这一切都会过去的！”；&lt;br&gt;世事如烟，沧海桑田，不管是好的还是坏的，没有一件事是永恒不变的。&lt;br&gt;对于那些看不透的，难以放下的事情，沉默是最好的武器，时间是最好的解药，会让一切过去。&lt;br&gt;不知道从什么时候开始，我疯狂地喜欢上了这句话：“宠辱不惊，闲看庭前花开花落，去留无意，漫随天外云卷云舒。”&lt;br&gt;它几乎成了我的人生箴言，每当我伤心难过，被人误解，工作不顺的时候，我就会用这句话来勉励自己；&lt;br&gt;人生数十载，我们现在所在意的，计较的，已得的，不过是生命长河里非常短暂的一瞬，几年或者十几年后在回过头来看，一切都是过眼云烟，完全不值得我们耿耿于怀。&lt;br&gt;往后余生，告诉自己，得也开心，失也淡定，看淡生命中发生的每一件事沉默安静，浅笑安然。&lt;br&gt;相信很多人都有这样的经历：&lt;br&gt;很喜欢在QQ空间里发表说说，或者发朋友圈，用简单的几句话，表达一些自己当时的所见所感，或者一些别人不易察觉的小心思。&lt;br&gt;等到多年之后，再去翻曾经发的说说，朋友圈，会觉得自己曾经的言论很矫情，恨不得全部删除。&lt;br&gt;其实，这就是生活的本质，不管当初多么欢喜，在意，随着时间的流逝，一切都会慢慢变淡，成了你生命中里一段缥缈的记忆。&lt;br&gt;所以，你越来越沉默，越来越不喜欢在人前表现自己，越来越深刻地明白；&lt;br&gt;爱过恨过，皆成经过，好事坏事，终成往事。&lt;br&gt;把心放宽，把事看淡，在沉默中独享自己的小心事，就是最好的生活方式。&lt;/p&gt;
&lt;p&gt;喜欢沉默，不过是因为越来越成熟。&lt;br&gt;看过这么一句话：&lt;br&gt;“没人会在乎你怎样在深夜里痛哭，也没人在乎你要辗转反侧的要熬过几个秋，外人只看结果，自己独撑过程”&lt;br&gt;等你明白了这个道理，便不会在人前矫情，&lt;br&gt;四处诉说以求宽慰。&lt;br&gt;当你越来越沉默，越来越不想说，应该是你越来越成熟，很多是看淡了，很多看轻了。&lt;br&gt;所以，当想争辩的时候，想一想，就算了，于是选择了沉默。&lt;br&gt;也不再像年少的时候那样，时时想着融入别人的世界。&lt;br&gt;年岁渐长，慢慢喜欢上安静和独处。&lt;br&gt;闲来无事，给自己和家人准备一顿精致的餐点。&lt;br&gt;打扫屋子，摆上自己买来的好看的小物件；&lt;br&gt;带着耳机，听着喜欢的音乐在公园里散步；&lt;br&gt;捧一本书，安静地呆一个下午。。。。。&lt;br&gt;如果你远远地看见一个人，端坐一隅，浅笑安然，不喧嚣，不张扬，他并没有不开心，只是觉得，沉默的状态，更舒服。&lt;br&gt;一个在聪明，也不能事事都看透；一个在智慧，也不能人人都看懂。&lt;br&gt;真正成熟的人，明白往事如流，人生最好的状态，不是避开车马喧嚣，而是在心中修篱种菊。&lt;br&gt;往后余生，愿你不争不抢，不闹不恼，不卑不亢，沉默以对，寂静欢喜。&lt;/p&gt;

    
    </summary>
    
    
      <category term="随笔" scheme="https://phantomabyss.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="heart" scheme="https://phantomabyss.github.io/tags/heart/"/>
    
  </entry>
  
</feed>
